# Smoother project-based collaboration {#smoother-collaboration}

```{r}
# zip from previous directory?
# proj_dir <- zip()
```

{{< include /includes/_wip.qmd >}}

Many of you probably work largely and mostly consistently on your own,
but as your move through your career (in academia or industry), you will
need to and maybe also want to *directly
collaborate*[^01-smoother-collaboration-1] a lot more with others.
Different types of collaboration (e.g. meetings, brainstorming,
real-time co-writing) form the basis for almost all research-based work
and probably most non-research-based work.

[^01-smoother-collaboration-1]: Collaborate here meaning directly
    contributing to a shared project, rather than discussed or planning
    based collaborations (and definitely not emailing-files-around
    collaboration).

More direct collaboration on a project quickly becomes unmanageable when
using traditional academic "workflows" (emailing around). That's when
you need to start using tools designed for collaboration, like Git. But
Git is just the starting point. There are many many other things to
consider for workflows and processes to effectively collaborate with
others. This session is about making use of more automated ways of
structuring data analysis projects to ease collaboration.

## Learning objectives

The overall objective for this session is to:

1.  Identify potential actions to streamline collaboration on a data
    analysis project and create projects that apply many of these
    actions using R.

More specific objectives are to:

1.  Explain what project-level R dependency management is, what a
    "project environment" is, and why these concepts are important to
    consider in collaborative and reproducible analyses.
2.  Describe the difference between "workflow dependencies" and "build
    dependencies".
3.  Apply functions in the `{renv}` and `{usethis}` R packages to
    implement these dependency management concepts.
4.  Explain the role that following a style guide has on building a
    common approach to reading (and writing) R code, and thus improve
    project-level collaboration.
5.  Use `{styler}`, `{lintr}`, and RStudio's canonical markdown mode to
    programmatically check and apply style guides to your project files.

## Project-level R dependency management

One of the first things to consider when working collaboratively on a
data analysis project (and probably other types of projects too) is what
software to use for your project. This starts out at the highest level:
Are you using R or some other software for the analysis? Since this is
an R course, so we're assuming the software will be R! ðŸ˜œ

The next consideration is which packages do you need that will
ultimately be the ones your project depends on to get the results that
you find. When working collaboratively with others, and yourself several
months in the future, you need some way of knowing how to easily and
quickly install or update these package dependencies.

Let's start with the `AdvancedR3` project that uses the `lipidomics`. We
have code in the `data-raw/nmr-omics.R` file that uses some packages.
Let's assume that your project will be more complex than this and that
you will eventually need some collaborators to contribute who are
experts in, for instance metabolomics data processing and in statistical
analysis of high-dimensional data. You know you will end up needing to
use other packages. You also know that you all need some way of tracking
which packages are used so that when others join and contribute to the
project, they can as seamlessly as possible install or update the
packages your data analysis project needs. There are a few ways of
"tracking" package dependencies.

```{markdown}
#| code-fold: true
#| code-summary: "test"
**Does** this work?
  Instructor comments: Get them to read this over? And then briefly talk about it?
```

1.  The simplest, but most primitive is to always make sure to use
    `library()` at the top of each R script for each package that the R
    script uses.

    -   Advantages:

        -   This is the easiest to conceptually understand and to use.

    -   Disadvantages:

        -   It doesn't track project-level dependencies very well, since
            multiple scripts probably use similar packages across them.
            Which means you can't easily and quickly install or update
            all the packages your project uses, since you will probably
            have to go through each R script manually and install each
            package manually. You might have seen some scripts with code
            that looks like this at the top:

            ``` r
            if (!require("packagename")) {
              install.packages("packagename")
            }
            ```

            What this code does is check if a package exists, if not,
            than it installs it. But! This is not an optimal methods to
            track packages because `require()` won't load the package if
            it doesn't find it. Which means you would have to re-run the
            script probably a few times. Plus, sometimes you may need to
            restart the R session after installing a package in order
            for R to detect it probably.

        -   It doesn't track the *versions* of the packages your project
            depends on, so if a package gets updated and it breaks
            something, you might not be able to figure out how to
            quickly fix that issue, especially for those deadline
            crunches.

2.  The most common form, at least based on R packages and projects
    found on GitHub, is making use of the `DESCRIPTION` file and
    `usethis::use_package()` to track which package is used for a
    project or not. We covered this style of dependency in the
    [intermediate
    course](https://r-cubed-intermediate.rostools.org/dry-functions.html#continuing-the-workflow).
    We will also use this approach during this course, but expand a lot
    more on it.

    -   Advantage:

        -   Relatively easy to conceptually understand, since you can
            directly view the packages your project needs by opening the
            `DESCRIPTION` file and looking at the contents.

        -   Because it is widely used, there are many processes already
            built around making use of tracking dependencies this way.
            For instance, you need to track package dependencies when
            creating R packages.

        -   Installing packages is as easy as opening the project and
            running `remotes::install_deps()` in the Console, which will
            install all the packages listed in the `DESCRIPTION` file.

        -   Adding packages that you need is as easy as writing
            `usethis::use_package("packagename")` in the Console.

    -   Disadvantage:

        -   Like the previous method, it doesn't easily keep track of
            the versions of the packages you are using.

        -   Your project might still rely on a package that is installed
            on *your* computer and that influences your project, but
            that might not be obvious as a dependency or that you forgot
            to include.

Before continuing to the exercise, we need to make sure to add and
comment all the files from the project into the Git history. Open the
Git interface by either typing `Ctrl-Shift-M` or by going to the Git
pane and clicking the "Commit" button.

## Exercise: Add packages from the data processing script

> Time: \~10 minutes.

Since the `DESCRIPTION` file will be used later on for the more formal
dependency management, let's get it updated with the packages we are
using in the `data-raw/nmr-omics.R` script. Open that file and complete
these tasks:

1.  Look for package dependencies that are declared with `library()` and
    `::`.
2.  Use `?usethis::use_package` to review how to use this function.
3.  In the Console, run `usethis::use_package()` for each package you
    find in `data-raw/nmr-omics.R` (from 1. above).
4.  Once done, open the Git interface (`Ctrl-Shift-M` or go to the Git
    Pane and click the "Commit" button). What has been changed?

```{r solution-add-processing-packages, eval=FALSE}
#| code-fold: true
#| code-summary: "**Click for the solution**. Only click if you are really struggling or are out of time for the exercise."
# TODO: Use solution code like past courses? Or the above?
usethis::use_package("readxl")
usethis::use_package("dplyr")
usethis::use_package("tidyr")
usethis::use_package("here")
usethis::use_package("fs")
usethis::use_package("usethis")
```

## Formal dependency management

-   Fully functioning and most powerful: Creating ... Python uses these
    heavily, called "virtual environments". These are relatively
    self-contained with lists these

    -   Advantage: Because every package that your project needs is
        installed and connected *only* to your project, it becomes very
        obvious (through errors) when you might be missing some other
        dependency. It's very powerful and can help with reproducibility
        when packages update

    -   Disadvantage: It takes more learning and work to figure out
        issues.

::: aside
It's sometimes very annoying to debug these "virtual environments". But
thankfully you can turn it off! It still is worth it to start
considering and accounting for how your dependencies might influence
your project results and collaboration.
:::

```{r, eval=FALSE}
renv::init()
```

-   Folders and files added:

    -   .Rprofile
    -   renv
    -   renv.lock

```{r, eval=FALSE}
renv::init()
```

```{r, eval=FALSE}
renv::status()
renv::snapshot()
```

```{r, eval=FALSE}
renv::restore()
```

-   set up environment

    -   Open `.Rprofile` and add:

    ``` r
    options(
        renv.settings.snapshot.type = "explicit",
        renv.config.auto.snapshot = TRUE
    )
    ```

Restart R session.

If it gets annoying, can always do: `renv::deactivate()`

Add and commit.

## Exercise: Browse the newly created renv folders and files

After running adding `{renv}` to the project, take a look through the
newly created `renv/` folder and see what was added. Where are the
packages now installed? Do you seeSee the packages added, and the
symlink

```{r, echo=FALSE}
fs::dir_tree(here::here("renv"))
```

## Project environments

what a "project environment" is

why these concepts are important to consider in collaborative and
reproducible analyses.

```{r}
# usethis::edit_r_profile("user")
```

```{r}
# usethis::edit_r_profile("project")
```

```{r}
fs::dir_tree(here::here("renv"), recurse = FALSE)
```

```{r}
.libPaths()
renv::deactivate()
.libPaths()
renv::activate()
```

## Two types of dependencies

When you work on a research project that involves data analysis, you
make use of two types of packages:

1.  Packages you need to directly complete the analysis and generate the
    results. These types of packages
2.  Packages that assist you in doing your work.

"workflow dependencies" and "build dependencies".

-   required vs helper packages (imports vs suggests)

    -   e.g. tidyverse in Depends?

-   use_usethis()

## Exercise:

1.  Is the `{renv}` package necessary for

## Programmatically follow a style guide

```{r}
styler::style_dir()
```

Ctrl-Shift-P

-   caching `cache_activate()`

```{r}
options(
  styler.addins_style_transformer = "styler::tidyverse_style(indent_by = 4)"
)
```

## Exercise: copy and paste code that is wrong.

Run lintr and see errors. Run styler to fix some of them up.

-   include something like `{{}}`
-   create a function in R to do it more efficiently (for styler)

## Automatic linting checks

Can add GitHub Actions with lintr?

## Exercise: Create GitHub repository

-   Check the SDCA ukbAid?

## Adding lintr to the repository

use_github_action("lint-project")

could even use

use_github_action("style")

this might be an extra.

## Standard markdown format

Briefly talk about the visual mode.

-   Quarto visual/canonical mode.

## Exercise:

## Summary

## Extras? (quick read)
