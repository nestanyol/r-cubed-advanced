{
  "hash": "38009fb8b6407411fa7e52dfaed3aca8",
  "result": {
    "markdown": "# Efficiently running many analyses at once {#sec-stats-analyses-multiple}\n\n::: callout-warning\nðŸš§ This section is being actively worked on. ðŸš§\n:::\n\n\n\n\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nBefore beginning, get them to recall what they remember of the previous\nsession, either with something like Mentimeter or verbally. Preferably\nsomething like Mentimeter because it allows everyone to participate, not\njust the ones who are more comfortable being vocal to the whole group.\n\nDepending on what they write, might need to briefly go over the previous\nsession.\n:::\n\nRarely do we run only one single statistical model to answer one single\nquestion, especially in our data-overflowing environments. An initial\ninstinct when faced with this task might be to copy-and-paste, then\nslightly modify the code each time. Or, if you have heard of loops or\nused them in other programming languages, you might think to create a\nloop. Thankfully R uses something more powerful and expressive than\neither of those approaches, and that is functional programming. Using\nfunctional programming concepts, we can use little code to express\ncomplex actions and run large numbers of statistical analyses.\n\nConnected to the concept of functional programming, is the idea of\nresampling a dataset multiple times and running the statistical analysis\non each resampled set to calculate a more accurate measure of\nuncertainty. We often use generic calculations of uncertainty like the\nstandard error or the confidence interval. Those are useful measures\nespecially with very large datasets, however, they have limitations of\ntheir own. By making use of resampling, we can identify how uncertain or\nunreliable a statistical result might be for our specific dataset. This\nsession will be about using functional programming in the context of\nstatistical analysis and learning about other methods of determining\nuncertainty.\n\n## Learning objectives\n\nThe overall objective for this session is to:\n\n1.  Describe the basic framework underlying most statistical analyses\n    and use R to generate statistical results using this framework.\n\nMore specific objectives are to:\n\n1.  Recall principles of functional programming and apply them to\n    running statistical analyses by using the `{purrr}` package.\n2.  Describe what a resampling technique is, the types available, and\n    why it can help estimate the variability of model results. Apply\n    functions from `{rsample}` and `{tune}` to use these techniques.\n3.  Continue applying the concepts and functions used from the previous\n    sessions.\n\nSpecific \"anti\"-objectives:\n\n-   Same as the \"anti\"-objectives of @sec-stats-analyses-basic.\n\n## Exercise: How would we use functional programming to run multiple models?\n\n> Time: \\~20 minutes.\n\nFunctional programming underlies many core features of running\nstatistical methods on data. This exercise is meant for you to review\nthis concept and try to think of it in the context of statistical\nmodeling.\n\n-   For 10 minutes, go to the sections on [Function\n    Programming](https://r-cubed-intermediate.rostools.org/dry-functionals.html#functional-programming)\n    in the Intermediate R course as well as the\n    [split-apply-combine](https://r-cubed-intermediate.rostools.org/dry-functionals.html#split-apply-combine-technique-and-functionals)\n    and review the concepts.\n\n-   For 8 minutes, discuss with your neighbour how we can use functional\n    programming to apply the statistical model to each metabolite. Try\n    to think how the code would look. You don't need to write real R\n    code, but if writing pseudocode helps, go right ahead! Also, don't\n    look ahead :wink:\n\n-   For the remaining time, we will discuss our thoughts in the whole\n    group.\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nAfter they've finished, either write pseudocode in RStudio or draw this\nout on a whiteboard if it is available. There will probably be several\ndifferent approaches, many of which could also be implemented just fine.\nUltimately we will replace `create_recipe_spec(metabolite_...)` with\n`create_recipe_spec(starts_with(\"metabolite_\"))`.\n:::\n\n## Apply logistic regression to each metabolite\n\nYou may have thought of many different ways to run the model on each\nmetabolite based on the `lipidomics_wide` dataset. However, these types\nof \"split-apply-combine\" tasks are (usually) best done using data in the\nlong form. So we'll start with the original `lipidomics` dataset. Create\na header and code chunk at the end of the `doc/lesson.Rmd` file:\n\n    ## Running multiple models\n\n    ```{{r}}\n\n    ```\n\nThe first thing we want to do is convert the metabolite names into snake\ncase:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  column_values_to_snakecase(metabolite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 504 Ã— 6\n   code   gender   age class metabolite                value\n   <chr>  <chr>  <dbl> <chr> <chr>                     <dbl>\n 1 ERI109 M         25 CT    tms_interntal_standard   208.  \n 2 ERI109 M         25 CT    cholesterol               19.8 \n 3 ERI109 M         25 CT    lipid_ch_3_1              44.1 \n 4 ERI109 M         25 CT    lipid_ch_3_2             147.  \n 5 ERI109 M         25 CT    cholesterol               27.2 \n 6 ERI109 M         25 CT    lipid_ch_2               587.  \n 7 ERI109 M         25 CT    fa_ch_2_ch_2_coo          31.6 \n 8 ERI109 M         25 CT    pufa                      29.0 \n 9 ERI109 M         25 CT    phosphatidylethanolamine   6.78\n10 ERI109 M         25 CT    phosphatidycholine        41.7 \n# â€¦ with 494 more rows\n```\n:::\n:::\n\n\nThe next step is to split the data up. We could use `group_by()`, but in\norder to make the most use of `{purrr}` functions like `map()`, we will\nuse `group_split()` to convert the data frame into a set of\nlists[^stats-analyses-multiple-1]. Let's first add `{purrr}` as a\ndependency:\n\n[^stats-analyses-multiple-1]: There is probably a more computationally\n    efficient way of coding this instead of making a list, but as the\n    saying goes [\"premature optimization is the root of all\n    evil\"](https://stackify.com/premature-optimization-evil/). For our\n    purposes, this is a very good approach, but for very large datasets\n    and hundreds of potential models to run, this method would need to\n    be optimized some more.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_package(\"purrr\")\n```\n:::\n\n\nThen we run `group_split()` on the `metabolite` column, which will\noutput a lot of data frames as a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  column_values_to_snakecase(metabolite) %>%\n  group_split(metabolite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n<list_of<\n  tbl_df<\n    code      : character\n    gender    : character\n    age       : double\n    class     : character\n    metabolite: character\n    value     : double\n  >\n>[12]>\n[[1]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite      value\n   <chr>  <chr>  <dbl> <chr> <chr>           <dbl>\n 1 ERI109 M         25 CT    cd_cl_3_solvent  166.\n 2 ERI111 M         39 CT    cd_cl_3_solvent  171.\n 3 ERI163 W         58 CT    cd_cl_3_solvent  262.\n 4 ERI375 M         24 CT    cd_cl_3_solvent  172.\n 5 ERI376 M         26 CT    cd_cl_3_solvent  300.\n 6 ERI391 M         31 CT    cd_cl_3_solvent  241.\n 7 ERI392 M         24 CT    cd_cl_3_solvent  172.\n 8 ERI79  W         26 CT    cd_cl_3_solvent  148.\n 9 ERI81  M         52 CT    cd_cl_3_solvent  168.\n10 ERI83  M         25 CT    cd_cl_3_solvent  253.\n# â€¦ with 26 more rows\n\n[[2]]\n# A tibble: 108 Ã— 6\n   code   gender   age class metabolite  value\n   <chr>  <chr>  <dbl> <chr> <chr>       <dbl>\n 1 ERI109 M         25 CT    cholesterol 19.8 \n 2 ERI109 M         25 CT    cholesterol 27.2 \n 3 ERI109 M         25 CT    cholesterol  8.88\n 4 ERI111 M         39 CT    cholesterol 22.8 \n 5 ERI111 M         39 CT    cholesterol 30.2 \n 6 ERI111 M         39 CT    cholesterol  9.28\n 7 ERI163 W         58 CT    cholesterol 14.9 \n 8 ERI163 W         58 CT    cholesterol 24.0 \n 9 ERI163 W         58 CT    cholesterol  7.66\n10 ERI375 M         24 CT    cholesterol 19.2 \n# â€¦ with 98 more rows\n\n[[3]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite       value\n   <chr>  <chr>  <dbl> <chr> <chr>            <dbl>\n 1 ERI109 M         25 CT    fa_ch_2_ch_2_coo  31.6\n 2 ERI111 M         39 CT    fa_ch_2_ch_2_coo  28.9\n 3 ERI163 W         58 CT    fa_ch_2_ch_2_coo  36.6\n 4 ERI375 M         24 CT    fa_ch_2_ch_2_coo  39.4\n 5 ERI376 M         26 CT    fa_ch_2_ch_2_coo  52.1\n 6 ERI391 M         31 CT    fa_ch_2_ch_2_coo  42.8\n 7 ERI392 M         24 CT    fa_ch_2_ch_2_coo  39.9\n 8 ERI79  W         26 CT    fa_ch_2_ch_2_coo  32.7\n 9 ERI81  M         52 CT    fa_ch_2_ch_2_coo  28.4\n10 ERI83  M         25 CT    fa_ch_2_ch_2_coo  26.5\n# â€¦ with 26 more rows\n\n[[4]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite value\n   <chr>  <chr>  <dbl> <chr> <chr>      <dbl>\n 1 ERI109 M         25 CT    lipid_ch_2  587.\n 2 ERI111 M         39 CT    lipid_ch_2  585.\n 3 ERI163 W         58 CT    lipid_ch_2  558.\n 4 ERI375 M         24 CT    lipid_ch_2  606.\n 5 ERI376 M         26 CT    lipid_ch_2  554.\n 6 ERI391 M         31 CT    lipid_ch_2  597.\n 7 ERI392 M         24 CT    lipid_ch_2  607.\n 8 ERI79  W         26 CT    lipid_ch_2  546.\n 9 ERI81  M         52 CT    lipid_ch_2  593.\n10 ERI83  M         25 CT    lipid_ch_2  606.\n# â€¦ with 26 more rows\n\n[[5]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite   value\n   <chr>  <chr>  <dbl> <chr> <chr>        <dbl>\n 1 ERI109 M         25 CT    lipid_ch_3_1  44.1\n 2 ERI111 M         39 CT    lipid_ch_3_1  28.1\n 3 ERI163 W         58 CT    lipid_ch_3_1  75.1\n 4 ERI375 M         24 CT    lipid_ch_3_1  22.0\n 5 ERI376 M         26 CT    lipid_ch_3_1  29.5\n 6 ERI391 M         31 CT    lipid_ch_3_1  38.0\n 7 ERI392 M         24 CT    lipid_ch_3_1  34.8\n 8 ERI79  W         26 CT    lipid_ch_3_1 109. \n 9 ERI81  M         52 CT    lipid_ch_3_1  49.6\n10 ERI83  M         25 CT    lipid_ch_3_1  29.9\n# â€¦ with 26 more rows\n\n[[6]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite   value\n   <chr>  <chr>  <dbl> <chr> <chr>        <dbl>\n 1 ERI109 M         25 CT    lipid_ch_3_2  147.\n 2 ERI111 M         39 CT    lipid_ch_3_2  153.\n 3 ERI163 W         58 CT    lipid_ch_3_2  144.\n 4 ERI375 M         24 CT    lipid_ch_3_2  220.\n 5 ERI376 M         26 CT    lipid_ch_3_2  282.\n 6 ERI391 M         31 CT    lipid_ch_3_2  220.\n 7 ERI392 M         24 CT    lipid_ch_3_2  215.\n 8 ERI79  W         26 CT    lipid_ch_3_2  153.\n 9 ERI81  M         52 CT    lipid_ch_3_2  150.\n10 ERI83  M         25 CT    lipid_ch_3_2  153.\n# â€¦ with 26 more rows\n\n[[7]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite  value\n   <chr>  <chr>  <dbl> <chr> <chr>       <dbl>\n 1 ERI109 M         25 CT    mufa_pufa  50.6  \n 2 ERI111 M         39 CT    mufa_pufa  53.2  \n 3 ERI163 W         58 CT    mufa_pufa  60.7  \n 4 ERI375 M         24 CT    mufa_pufa   0.532\n 5 ERI376 M         26 CT    mufa_pufa   1.15 \n 6 ERI391 M         31 CT    mufa_pufa   0.602\n 7 ERI392 M         24 CT    mufa_pufa   0.422\n 8 ERI79  W         26 CT    mufa_pufa  36.3  \n 9 ERI81  M         52 CT    mufa_pufa  40.1  \n10 ERI83  M         25 CT    mufa_pufa  39.3  \n# â€¦ with 26 more rows\n\n[[8]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite         value\n   <chr>  <chr>  <dbl> <chr> <chr>              <dbl>\n 1 ERI109 M         25 CT    phosphatidycholine  41.7\n 2 ERI111 M         39 CT    phosphatidycholine  52.9\n 3 ERI163 W         58 CT    phosphatidycholine  35.3\n 4 ERI375 M         24 CT    phosphatidycholine  66.9\n 5 ERI376 M         26 CT    phosphatidycholine  32.7\n 6 ERI391 M         31 CT    phosphatidycholine  62.9\n 7 ERI392 M         24 CT    phosphatidycholine  64.3\n 8 ERI79  W         26 CT    phosphatidycholine  41.0\n 9 ERI81  M         52 CT    phosphatidycholine  56.1\n10 ERI83  M         25 CT    phosphatidycholine  57.8\n# â€¦ with 26 more rows\n\n[[9]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite               value\n   <chr>  <chr>  <dbl> <chr> <chr>                    <dbl>\n 1 ERI109 M         25 CT    phosphatidylethanolamine  6.78\n 2 ERI111 M         39 CT    phosphatidylethanolamine  3.66\n 3 ERI163 W         58 CT    phosphatidylethanolamine  3.59\n 4 ERI375 M         24 CT    phosphatidylethanolamine  3.59\n 5 ERI376 M         26 CT    phosphatidylethanolamine  2.33\n 6 ERI391 M         31 CT    phosphatidylethanolamine  1.46\n 7 ERI392 M         24 CT    phosphatidylethanolamine  2.00\n 8 ERI79  W         26 CT    phosphatidylethanolamine  4.93\n 9 ERI81  M         52 CT    phosphatidylethanolamine  5.20\n10 ERI83  M         25 CT    phosphatidylethanolamine  5.01\n# â€¦ with 26 more rows\n\n[[10]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite    value\n   <chr>  <chr>  <dbl> <chr> <chr>         <dbl>\n 1 ERI109 M         25 CT    phospholipids  5.58\n 2 ERI111 M         39 CT    phospholipids  6.16\n 3 ERI163 W         58 CT    phospholipids  5.19\n 4 ERI375 M         24 CT    phospholipids  4.20\n 5 ERI376 M         26 CT    phospholipids  3.27\n 6 ERI391 M         31 CT    phospholipids  4.71\n 7 ERI392 M         24 CT    phospholipids  4.14\n 8 ERI79  W         26 CT    phospholipids  5.70\n 9 ERI81  M         52 CT    phospholipids  5.46\n10 ERI83  M         25 CT    phospholipids  4.89\n# â€¦ with 26 more rows\n\n[[11]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite value\n   <chr>  <chr>  <dbl> <chr> <chr>      <dbl>\n 1 ERI109 M         25 CT    pufa       29.0 \n 2 ERI111 M         39 CT    pufa       27.4 \n 3 ERI163 W         58 CT    pufa       35.5 \n 4 ERI375 M         24 CT    pufa        6.92\n 5 ERI376 M         26 CT    pufa        3.22\n 6 ERI391 M         31 CT    pufa        3.43\n 7 ERI392 M         24 CT    pufa        3.52\n 8 ERI79  W         26 CT    pufa       18.7 \n 9 ERI81  M         52 CT    pufa       20.7 \n10 ERI83  M         25 CT    pufa       18.2 \n# â€¦ with 26 more rows\n\n[[12]]\n# A tibble: 36 Ã— 6\n   code   gender   age class metabolite             value\n   <chr>  <chr>  <dbl> <chr> <chr>                  <dbl>\n 1 ERI109 M         25 CT    tms_interntal_standard 208. \n 2 ERI111 M         39 CT    tms_interntal_standard 219. \n 3 ERI163 W         58 CT    tms_interntal_standard  57.1\n 4 ERI375 M         24 CT    tms_interntal_standard  19.2\n 5 ERI376 M         26 CT    tms_interntal_standard  35.4\n 6 ERI391 M         31 CT    tms_interntal_standard  30.4\n 7 ERI392 M         24 CT    tms_interntal_standard  21.7\n 8 ERI79  W         26 CT    tms_interntal_standard 185. \n 9 ERI81  M         52 CT    tms_interntal_standard 207. \n10 ERI83  M         25 CT    tms_interntal_standard 322. \n# â€¦ with 26 more rows\n```\n:::\n:::\n\n\nRemember that logistic regression models need each row to be a single\nperson, so we'll use the functional `map()` to apply our custom function\n`metabolites_to_wider()` on each of the split list items:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  column_values_to_snakecase(metabolite) %>%\n  group_split(metabolite) %>%\n  map(metabolites_to_wider)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n[[1]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_cd_cl_3_solvent\n   <chr>  <chr>  <dbl> <chr>                      <dbl>\n 1 ERI109 M         25 CT                          166.\n 2 ERI111 M         39 CT                          171.\n 3 ERI163 W         58 CT                          262.\n 4 ERI375 M         24 CT                          172.\n 5 ERI376 M         26 CT                          300.\n 6 ERI391 M         31 CT                          241.\n 7 ERI392 M         24 CT                          172.\n 8 ERI79  W         26 CT                          148.\n 9 ERI81  M         52 CT                          168.\n10 ERI83  M         25 CT                          253.\n# â€¦ with 26 more rows\n\n[[2]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_cholesterol\n   <chr>  <chr>  <dbl> <chr>                  <dbl>\n 1 ERI109 M         25 CT                     18.6 \n 2 ERI111 M         39 CT                     20.8 \n 3 ERI163 W         58 CT                     15.5 \n 4 ERI375 M         24 CT                     10.2 \n 5 ERI376 M         26 CT                     13.5 \n 6 ERI391 M         31 CT                      9.53\n 7 ERI392 M         24 CT                      9.87\n 8 ERI79  W         26 CT                     17.6 \n 9 ERI81  M         52 CT                     17.0 \n10 ERI83  M         25 CT                     19.7 \n# â€¦ with 26 more rows\n\n[[3]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_fa_ch_2_ch_2_coo\n   <chr>  <chr>  <dbl> <chr>                       <dbl>\n 1 ERI109 M         25 CT                           31.6\n 2 ERI111 M         39 CT                           28.9\n 3 ERI163 W         58 CT                           36.6\n 4 ERI375 M         24 CT                           39.4\n 5 ERI376 M         26 CT                           52.1\n 6 ERI391 M         31 CT                           42.8\n 7 ERI392 M         24 CT                           39.9\n 8 ERI79  W         26 CT                           32.7\n 9 ERI81  M         52 CT                           28.4\n10 ERI83  M         25 CT                           26.5\n# â€¦ with 26 more rows\n\n[[4]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_lipid_ch_2\n   <chr>  <chr>  <dbl> <chr>                 <dbl>\n 1 ERI109 M         25 CT                     587.\n 2 ERI111 M         39 CT                     585.\n 3 ERI163 W         58 CT                     558.\n 4 ERI375 M         24 CT                     606.\n 5 ERI376 M         26 CT                     554.\n 6 ERI391 M         31 CT                     597.\n 7 ERI392 M         24 CT                     607.\n 8 ERI79  W         26 CT                     546.\n 9 ERI81  M         52 CT                     593.\n10 ERI83  M         25 CT                     606.\n# â€¦ with 26 more rows\n\n[[5]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_lipid_ch_3_1\n   <chr>  <chr>  <dbl> <chr>                   <dbl>\n 1 ERI109 M         25 CT                       44.1\n 2 ERI111 M         39 CT                       28.1\n 3 ERI163 W         58 CT                       75.1\n 4 ERI375 M         24 CT                       22.0\n 5 ERI376 M         26 CT                       29.5\n 6 ERI391 M         31 CT                       38.0\n 7 ERI392 M         24 CT                       34.8\n 8 ERI79  W         26 CT                      109. \n 9 ERI81  M         52 CT                       49.6\n10 ERI83  M         25 CT                       29.9\n# â€¦ with 26 more rows\n\n[[6]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_lipid_ch_3_2\n   <chr>  <chr>  <dbl> <chr>                   <dbl>\n 1 ERI109 M         25 CT                       147.\n 2 ERI111 M         39 CT                       153.\n 3 ERI163 W         58 CT                       144.\n 4 ERI375 M         24 CT                       220.\n 5 ERI376 M         26 CT                       282.\n 6 ERI391 M         31 CT                       220.\n 7 ERI392 M         24 CT                       215.\n 8 ERI79  W         26 CT                       153.\n 9 ERI81  M         52 CT                       150.\n10 ERI83  M         25 CT                       153.\n# â€¦ with 26 more rows\n\n[[7]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_mufa_pufa\n   <chr>  <chr>  <dbl> <chr>                <dbl>\n 1 ERI109 M         25 CT                  50.6  \n 2 ERI111 M         39 CT                  53.2  \n 3 ERI163 W         58 CT                  60.7  \n 4 ERI375 M         24 CT                   0.532\n 5 ERI376 M         26 CT                   1.15 \n 6 ERI391 M         31 CT                   0.602\n 7 ERI392 M         24 CT                   0.422\n 8 ERI79  W         26 CT                  36.3  \n 9 ERI81  M         52 CT                  40.1  \n10 ERI83  M         25 CT                  39.3  \n# â€¦ with 26 more rows\n\n[[8]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_phosphatidycholine\n   <chr>  <chr>  <dbl> <chr>                         <dbl>\n 1 ERI109 M         25 CT                             41.7\n 2 ERI111 M         39 CT                             52.9\n 3 ERI163 W         58 CT                             35.3\n 4 ERI375 M         24 CT                             66.9\n 5 ERI376 M         26 CT                             32.7\n 6 ERI391 M         31 CT                             62.9\n 7 ERI392 M         24 CT                             64.3\n 8 ERI79  W         26 CT                             41.0\n 9 ERI81  M         52 CT                             56.1\n10 ERI83  M         25 CT                             57.8\n# â€¦ with 26 more rows\n\n[[9]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_phosphatidylethanolamine\n   <chr>  <chr>  <dbl> <chr>                               <dbl>\n 1 ERI109 M         25 CT                                   6.78\n 2 ERI111 M         39 CT                                   3.66\n 3 ERI163 W         58 CT                                   3.59\n 4 ERI375 M         24 CT                                   3.59\n 5 ERI376 M         26 CT                                   2.33\n 6 ERI391 M         31 CT                                   1.46\n 7 ERI392 M         24 CT                                   2.00\n 8 ERI79  W         26 CT                                   4.93\n 9 ERI81  M         52 CT                                   5.20\n10 ERI83  M         25 CT                                   5.01\n# â€¦ with 26 more rows\n\n[[10]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_phospholipids\n   <chr>  <chr>  <dbl> <chr>                    <dbl>\n 1 ERI109 M         25 CT                        5.58\n 2 ERI111 M         39 CT                        6.16\n 3 ERI163 W         58 CT                        5.19\n 4 ERI375 M         24 CT                        4.20\n 5 ERI376 M         26 CT                        3.27\n 6 ERI391 M         31 CT                        4.71\n 7 ERI392 M         24 CT                        4.14\n 8 ERI79  W         26 CT                        5.70\n 9 ERI81  M         52 CT                        5.46\n10 ERI83  M         25 CT                        4.89\n# â€¦ with 26 more rows\n\n[[11]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_pufa\n   <chr>  <chr>  <dbl> <chr>           <dbl>\n 1 ERI109 M         25 CT              29.0 \n 2 ERI111 M         39 CT              27.4 \n 3 ERI163 W         58 CT              35.5 \n 4 ERI375 M         24 CT               6.92\n 5 ERI376 M         26 CT               3.22\n 6 ERI391 M         31 CT               3.43\n 7 ERI392 M         24 CT               3.52\n 8 ERI79  W         26 CT              18.7 \n 9 ERI81  M         52 CT              20.7 \n10 ERI83  M         25 CT              18.2 \n# â€¦ with 26 more rows\n\n[[12]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_tms_interntal_standard\n   <chr>  <chr>  <dbl> <chr>                             <dbl>\n 1 ERI109 M         25 CT                                208. \n 2 ERI111 M         39 CT                                219. \n 3 ERI163 W         58 CT                                 57.1\n 4 ERI375 M         24 CT                                 19.2\n 5 ERI376 M         26 CT                                 35.4\n 6 ERI391 M         31 CT                                 30.4\n 7 ERI392 M         24 CT                                 21.7\n 8 ERI79  W         26 CT                                185. \n 9 ERI81  M         52 CT                                207. \n10 ERI83  M         25 CT                                322. \n# â€¦ with 26 more rows\n```\n:::\n:::\n\n\nAlright, we now a list of data frames where each data frame has only one\nof the metabolites. These bits of code represent the conceptual action\nof \"splitting the data into a list by metabolites\". Since we're\nfollowing a function-oriented workflow, let's create a function for\nthis. Convert it into a function, add the Roxygen comments (have the cursor inside the function, type `Ctrl-Shift-P`, then type \"roxygen\"), run\n`{styler}` (`Ctrl-Shift-P`, then type \"style file\"), move into the `R/functions.R` file, and then\n`source()` the file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Convert the long form dataset into a list of wide form data frames.\n#'\n#' @param data The lipidomics dataset.\n#'\n#' @return A list of data frames.\n#'\nsplit_by_metabolite <- function(data) {\n  data %>%\n    column_values_to_snakecase(metabolite) %>%\n    dplyr::group_split(metabolite) %>%\n    purrr::map(metabolites_to_wider)\n}\n```\n:::\n\n\nIn the `doc/lesson.Rmd`, use the new function in the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  split_by_metabolite()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n[[1]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_cd_cl_3_solvent\n   <chr>  <chr>  <dbl> <chr>                      <dbl>\n 1 ERI109 M         25 CT                          166.\n 2 ERI111 M         39 CT                          171.\n 3 ERI163 W         58 CT                          262.\n 4 ERI375 M         24 CT                          172.\n 5 ERI376 M         26 CT                          300.\n 6 ERI391 M         31 CT                          241.\n 7 ERI392 M         24 CT                          172.\n 8 ERI79  W         26 CT                          148.\n 9 ERI81  M         52 CT                          168.\n10 ERI83  M         25 CT                          253.\n# â€¦ with 26 more rows\n\n[[2]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_cholesterol\n   <chr>  <chr>  <dbl> <chr>                  <dbl>\n 1 ERI109 M         25 CT                     18.6 \n 2 ERI111 M         39 CT                     20.8 \n 3 ERI163 W         58 CT                     15.5 \n 4 ERI375 M         24 CT                     10.2 \n 5 ERI376 M         26 CT                     13.5 \n 6 ERI391 M         31 CT                      9.53\n 7 ERI392 M         24 CT                      9.87\n 8 ERI79  W         26 CT                     17.6 \n 9 ERI81  M         52 CT                     17.0 \n10 ERI83  M         25 CT                     19.7 \n# â€¦ with 26 more rows\n\n[[3]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_fa_ch_2_ch_2_coo\n   <chr>  <chr>  <dbl> <chr>                       <dbl>\n 1 ERI109 M         25 CT                           31.6\n 2 ERI111 M         39 CT                           28.9\n 3 ERI163 W         58 CT                           36.6\n 4 ERI375 M         24 CT                           39.4\n 5 ERI376 M         26 CT                           52.1\n 6 ERI391 M         31 CT                           42.8\n 7 ERI392 M         24 CT                           39.9\n 8 ERI79  W         26 CT                           32.7\n 9 ERI81  M         52 CT                           28.4\n10 ERI83  M         25 CT                           26.5\n# â€¦ with 26 more rows\n\n[[4]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_lipid_ch_2\n   <chr>  <chr>  <dbl> <chr>                 <dbl>\n 1 ERI109 M         25 CT                     587.\n 2 ERI111 M         39 CT                     585.\n 3 ERI163 W         58 CT                     558.\n 4 ERI375 M         24 CT                     606.\n 5 ERI376 M         26 CT                     554.\n 6 ERI391 M         31 CT                     597.\n 7 ERI392 M         24 CT                     607.\n 8 ERI79  W         26 CT                     546.\n 9 ERI81  M         52 CT                     593.\n10 ERI83  M         25 CT                     606.\n# â€¦ with 26 more rows\n\n[[5]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_lipid_ch_3_1\n   <chr>  <chr>  <dbl> <chr>                   <dbl>\n 1 ERI109 M         25 CT                       44.1\n 2 ERI111 M         39 CT                       28.1\n 3 ERI163 W         58 CT                       75.1\n 4 ERI375 M         24 CT                       22.0\n 5 ERI376 M         26 CT                       29.5\n 6 ERI391 M         31 CT                       38.0\n 7 ERI392 M         24 CT                       34.8\n 8 ERI79  W         26 CT                      109. \n 9 ERI81  M         52 CT                       49.6\n10 ERI83  M         25 CT                       29.9\n# â€¦ with 26 more rows\n\n[[6]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_lipid_ch_3_2\n   <chr>  <chr>  <dbl> <chr>                   <dbl>\n 1 ERI109 M         25 CT                       147.\n 2 ERI111 M         39 CT                       153.\n 3 ERI163 W         58 CT                       144.\n 4 ERI375 M         24 CT                       220.\n 5 ERI376 M         26 CT                       282.\n 6 ERI391 M         31 CT                       220.\n 7 ERI392 M         24 CT                       215.\n 8 ERI79  W         26 CT                       153.\n 9 ERI81  M         52 CT                       150.\n10 ERI83  M         25 CT                       153.\n# â€¦ with 26 more rows\n\n[[7]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_mufa_pufa\n   <chr>  <chr>  <dbl> <chr>                <dbl>\n 1 ERI109 M         25 CT                  50.6  \n 2 ERI111 M         39 CT                  53.2  \n 3 ERI163 W         58 CT                  60.7  \n 4 ERI375 M         24 CT                   0.532\n 5 ERI376 M         26 CT                   1.15 \n 6 ERI391 M         31 CT                   0.602\n 7 ERI392 M         24 CT                   0.422\n 8 ERI79  W         26 CT                  36.3  \n 9 ERI81  M         52 CT                  40.1  \n10 ERI83  M         25 CT                  39.3  \n# â€¦ with 26 more rows\n\n[[8]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_phosphatidycholine\n   <chr>  <chr>  <dbl> <chr>                         <dbl>\n 1 ERI109 M         25 CT                             41.7\n 2 ERI111 M         39 CT                             52.9\n 3 ERI163 W         58 CT                             35.3\n 4 ERI375 M         24 CT                             66.9\n 5 ERI376 M         26 CT                             32.7\n 6 ERI391 M         31 CT                             62.9\n 7 ERI392 M         24 CT                             64.3\n 8 ERI79  W         26 CT                             41.0\n 9 ERI81  M         52 CT                             56.1\n10 ERI83  M         25 CT                             57.8\n# â€¦ with 26 more rows\n\n[[9]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_phosphatidylethanolamine\n   <chr>  <chr>  <dbl> <chr>                               <dbl>\n 1 ERI109 M         25 CT                                   6.78\n 2 ERI111 M         39 CT                                   3.66\n 3 ERI163 W         58 CT                                   3.59\n 4 ERI375 M         24 CT                                   3.59\n 5 ERI376 M         26 CT                                   2.33\n 6 ERI391 M         31 CT                                   1.46\n 7 ERI392 M         24 CT                                   2.00\n 8 ERI79  W         26 CT                                   4.93\n 9 ERI81  M         52 CT                                   5.20\n10 ERI83  M         25 CT                                   5.01\n# â€¦ with 26 more rows\n\n[[10]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_phospholipids\n   <chr>  <chr>  <dbl> <chr>                    <dbl>\n 1 ERI109 M         25 CT                        5.58\n 2 ERI111 M         39 CT                        6.16\n 3 ERI163 W         58 CT                        5.19\n 4 ERI375 M         24 CT                        4.20\n 5 ERI376 M         26 CT                        3.27\n 6 ERI391 M         31 CT                        4.71\n 7 ERI392 M         24 CT                        4.14\n 8 ERI79  W         26 CT                        5.70\n 9 ERI81  M         52 CT                        5.46\n10 ERI83  M         25 CT                        4.89\n# â€¦ with 26 more rows\n\n[[11]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_pufa\n   <chr>  <chr>  <dbl> <chr>           <dbl>\n 1 ERI109 M         25 CT              29.0 \n 2 ERI111 M         39 CT              27.4 \n 3 ERI163 W         58 CT              35.5 \n 4 ERI375 M         24 CT               6.92\n 5 ERI376 M         26 CT               3.22\n 6 ERI391 M         31 CT               3.43\n 7 ERI392 M         24 CT               3.52\n 8 ERI79  W         26 CT              18.7 \n 9 ERI81  M         52 CT              20.7 \n10 ERI83  M         25 CT              18.2 \n# â€¦ with 26 more rows\n\n[[12]]\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_tms_interntal_standard\n   <chr>  <chr>  <dbl> <chr>                             <dbl>\n 1 ERI109 M         25 CT                                208. \n 2 ERI111 M         39 CT                                219. \n 3 ERI163 W         58 CT                                 57.1\n 4 ERI375 M         24 CT                                 19.2\n 5 ERI376 M         26 CT                                 35.4\n 6 ERI391 M         31 CT                                 30.4\n 7 ERI392 M         24 CT                                 21.7\n 8 ERI79  W         26 CT                                185. \n 9 ERI81  M         52 CT                                207. \n10 ERI83  M         25 CT                                322. \n# â€¦ with 26 more rows\n```\n:::\n:::\n\n\nLike we did with the `metabolite_to_wider()`, we need to pipe the output\ninto another `map()` function that has a custom function running the\nmodels. We don't have this function yet, so we need to create it. Let's\nconvert the modeling code we used in the exercise above into a function,\nreplacing `lipidomics` with `data` and using\n`starts_with(\"metabolite_\")` within the `create_recipe_spec()`. Add the\nRoxygen comments (have the cursor inside the function, type `Ctrl-Shift-P`, then type \"roxygen\"), run `{styler}` (`Ctrl-Shift-P`, then type \"style file\"), move into the\n`R/functions.R` file, and then `source()` the file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Generate the results of a model\n#'\n#' @param data The lipidomics dataset.\n#'\n#' @return A data frame.\n#'\ngenerate_model_results <- function(data) {\n  create_model_workflow(\n    parsnip::logistic_reg() %>%\n      parsnip::set_engine(\"glm\"),\n    data %>%\n      create_recipe_spec(tidyselect::starts_with(\"metabolite_\"))\n  ) %>%\n    parsnip::fit(data) %>%\n    tidy_model_output()\n}\n```\n:::\n\n\nThen we add it to the end of the pipe, but using `map_dfr()` to convert\nto a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  split_by_metabolite() %>%\n  map_dfr(generate_model_results)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: glm.fit: algorithm did not converge\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: glm.fit: fitted probabilities numerically 0 or 1 occurred\n\nWarning: glm.fit: fitted probabilities numerically 0 or 1 occurred\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 48 Ã— 5\n   term                       estimate std.error statistic p.value\n   <chr>                         <dbl>     <dbl>     <dbl>   <dbl>\n 1 (Intercept)                  0.855     1.57     -0.0995 0.921  \n 2 genderW                      3.18      0.943     1.23   0.220  \n 3 age                          0.981     0.0478   -0.412  0.680  \n 4 metabolite_cd_cl_3_solvent   0.0870    0.865    -2.82   0.00475\n 5 (Intercept)                  1.11      1.29      0.0817 0.935  \n 6 genderW                      0.493     0.779    -0.907  0.365  \n 7 age                          1.01      0.0377    0.183  0.855  \n 8 metabolite_cholesterol       2.97      0.458     2.38   0.0175 \n 9 (Intercept)                  0.944     1.19     -0.0481 0.962  \n10 genderW                      1.38      0.746     0.428  0.668  \n# â€¦ with 38 more rows\n```\n:::\n:::\n\n\nSince we are only interested in the model results for the metabolites,\nlet's keep only the `term` rows that are metabolites using `filter()`\nand `str_detect()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_estimates <- lipidomics %>%\n  split_by_metabolite() %>%\n  map_dfr(generate_model_results) %>%\n  filter(str_detect(term, \"metabolite_\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: glm.fit: algorithm did not converge\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: glm.fit: fitted probabilities numerically 0 or 1 occurred\n\nWarning: glm.fit: fitted probabilities numerically 0 or 1 occurred\n```\n:::\n\n```{.r .cell-code}\nmodel_estimates\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 12 Ã— 5\n   term                            estimate std.eâ€¦Â¹ statisâ€¦Â² p.value\n   <chr>                              <dbl>   <dbl>    <dbl>   <dbl>\n 1 metabolite_cd_cl_3_solvent     8.70e-  2 8.65e-1 -2.82e+0 0.00475\n 2 metabolite_cholesterol         2.97e+  0 4.58e-1  2.38e+0 0.0175 \n 3 metabolite_fa_ch_2_ch_2_coo    1.52e+  0 3.87e-1  1.09e+0 0.276  \n 4 metabolite_lipid_ch_2          2.59e-  3 3.14e+0 -1.90e+0 0.0578 \n 5 metabolite_lipid_ch_3_1        4.45e+  1 1.41e+0  2.70e+0 0.00697\n 6 metabolite_lipid_ch_3_2        8.85e-  1 3.61e-1 -3.39e-1 0.734  \n 7 metabolite_mufa_pufa           4.56e-  1 4.49e-1 -1.75e+0 0.0798 \n 8 metabolite_phosphatidycholine  1.28e-120 1.17e+5 -2.37e-3 0.998  \n 9 metabolite_phosphatidylethanoâ€¦ 2.69e+  1 1.32e+0  2.49e+0 0.0129 \n10 metabolite_phospholipids       2.39e- 19 6.90e+4 -6.22e-4 1.00   \n11 metabolite_pufa                3.27e+  0 5.60e-1  2.11e+0 0.0345 \n12 metabolite_tms_interntal_stanâ€¦ 5.62e-  2 9.90e-1 -2.91e+0 0.00363\n# â€¦ with abbreviated variable names Â¹â€‹std.error, Â²â€‹statistic\n```\n:::\n:::\n\n\nWow! We're basically at our first `{targets}` output! Before continuing,\nthere is one aesthetic thing we can add: The original variable names,\nrather than the snake case version. Since the original variable still\nexists in our `lipidomics` dataset, we can join it to the\n`model_estimates` object with `right_join()`, along with a few other\nminor changes. First, we'll `select()` only the `metabolite` and then\ncreate a duplicate column of `metabolite` called `term` (to match the\n`model_estimates`) using `mutate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  select(metabolite) %>%\n  mutate(term = metabolite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 504 Ã— 2\n   metabolite               term                    \n   <chr>                    <chr>                   \n 1 TMS (interntal standard) TMS (interntal standard)\n 2 Cholesterol              Cholesterol             \n 3 Lipid CH3- 1             Lipid CH3- 1            \n 4 Lipid CH3- 2             Lipid CH3- 2            \n 5 Cholesterol              Cholesterol             \n 6 Lipid -CH2-              Lipid -CH2-             \n 7 FA -CH2CH2COO-           FA -CH2CH2COO-          \n 8 PUFA                     PUFA                    \n 9 Phosphatidylethanolamine Phosphatidylethanolamine\n10 Phosphatidycholine       Phosphatidycholine      \n# â€¦ with 494 more rows\n```\n:::\n:::\n\n\nRight after that we will use our custom `column_values_to_snakecase()`\nfunction on the `term` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  select(metabolite) %>%\n  mutate(term = metabolite) %>%\n  column_values_to_snakecase(term)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 504 Ã— 2\n   metabolite               term                    \n   <chr>                    <chr>                   \n 1 TMS (interntal standard) tms_interntal_standard  \n 2 Cholesterol              cholesterol             \n 3 Lipid CH3- 1             lipid_ch_3_1            \n 4 Lipid CH3- 2             lipid_ch_3_2            \n 5 Cholesterol              cholesterol             \n 6 Lipid -CH2-              lipid_ch_2              \n 7 FA -CH2CH2COO-           fa_ch_2_ch_2_coo        \n 8 PUFA                     pufa                    \n 9 Phosphatidylethanolamine phosphatidylethanolamine\n10 Phosphatidycholine       phosphatidycholine      \n# â€¦ with 494 more rows\n```\n:::\n:::\n\n\nWe can see that we are missing the `metabolite_` text before each snake\ncase'd name, so we can add that with `mutate()` and `str_c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  select(metabolite) %>%\n  mutate(term = metabolite) %>%\n  column_values_to_snakecase(term) %>%\n  mutate(term = str_c(\"metabolite_\", term))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 504 Ã— 2\n   metabolite               term                               \n   <chr>                    <chr>                              \n 1 TMS (interntal standard) metabolite_tms_interntal_standard  \n 2 Cholesterol              metabolite_cholesterol             \n 3 Lipid CH3- 1             metabolite_lipid_ch_3_1            \n 4 Lipid CH3- 2             metabolite_lipid_ch_3_2            \n 5 Cholesterol              metabolite_cholesterol             \n 6 Lipid -CH2-              metabolite_lipid_ch_2              \n 7 FA -CH2CH2COO-           metabolite_fa_ch_2_ch_2_coo        \n 8 PUFA                     metabolite_pufa                    \n 9 Phosphatidylethanolamine metabolite_phosphatidylethanolamine\n10 Phosphatidycholine       metabolite_phosphatidycholine      \n# â€¦ with 494 more rows\n```\n:::\n:::\n\n\nThere are 504 rows, but we only need the unique values of `term` and\n`metabolite`, which we can get with `distinct()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  mutate(term = metabolite) %>%\n  column_values_to_snakecase(term) %>%\n  mutate(term = str_c(\"metabolite_\", term)) %>%\n  distinct(term, metabolite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 12 Ã— 2\n   metabolite               term                               \n   <chr>                    <chr>                              \n 1 TMS (interntal standard) metabolite_tms_interntal_standard  \n 2 Cholesterol              metabolite_cholesterol             \n 3 Lipid CH3- 1             metabolite_lipid_ch_3_1            \n 4 Lipid CH3- 2             metabolite_lipid_ch_3_2            \n 5 Lipid -CH2-              metabolite_lipid_ch_2              \n 6 FA -CH2CH2COO-           metabolite_fa_ch_2_ch_2_coo        \n 7 PUFA                     metabolite_pufa                    \n 8 Phosphatidylethanolamine metabolite_phosphatidylethanolamine\n 9 Phosphatidycholine       metabolite_phosphatidycholine      \n10 Phospholipids            metabolite_phospholipids           \n11 MUFA+PUFA                metabolite_mufa_pufa               \n12 CDCl3 (solvent)          metabolite_cd_cl_3_solvent         \n```\n:::\n:::\n\n\nThe last step is to `right_join()` with the `model_estimates`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics %>%\n  mutate(term = metabolite) %>%\n  column_values_to_snakecase(term) %>%\n  mutate(term = str_c(\"metabolite_\", term)) %>%\n  distinct(term, metabolite) %>%\n  right_join(model_estimates, by = \"term\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 12 Ã— 6\n   metabolite               term   estimate std.eâ€¦Â¹ statisâ€¦Â² p.value\n   <chr>                    <chr>     <dbl>   <dbl>    <dbl>   <dbl>\n 1 TMS (interntal standard) metaâ€¦ 5.62e-  2 9.90e-1 -2.91e+0 0.00363\n 2 Cholesterol              metaâ€¦ 2.97e+  0 4.58e-1  2.38e+0 0.0175 \n 3 Lipid CH3- 1             metaâ€¦ 4.45e+  1 1.41e+0  2.70e+0 0.00697\n 4 Lipid CH3- 2             metaâ€¦ 8.85e-  1 3.61e-1 -3.39e-1 0.734  \n 5 Lipid -CH2-              metaâ€¦ 2.59e-  3 3.14e+0 -1.90e+0 0.0578 \n 6 FA -CH2CH2COO-           metaâ€¦ 1.52e+  0 3.87e-1  1.09e+0 0.276  \n 7 PUFA                     metaâ€¦ 3.27e+  0 5.60e-1  2.11e+0 0.0345 \n 8 Phosphatidylethanolamine metaâ€¦ 2.69e+  1 1.32e+0  2.49e+0 0.0129 \n 9 Phosphatidycholine       metaâ€¦ 1.28e-120 1.17e+5 -2.37e-3 0.998  \n10 Phospholipids            metaâ€¦ 2.39e- 19 6.90e+4 -6.22e-4 1.00   \n11 MUFA+PUFA                metaâ€¦ 4.56e-  1 4.49e-1 -1.75e+0 0.0798 \n12 CDCl3 (solvent)          metaâ€¦ 8.70e-  2 8.65e-1 -2.82e+0 0.00475\n# â€¦ with abbreviated variable names Â¹â€‹std.error, Â²â€‹statistic\n```\n:::\n:::\n\n\nAwesome :smile: Now can you guess what we are going to do next? That's\nright, making a function of both the model creation code and this code\nto add the original variable names. Then we can add our first\n`{targets}` output!\n\n## Exercise: Creating functions for model results and adding as a target in the pipeline\n\n> Time: \\~25 minutes.\n\nConvert the code that calculates the model estimates as well as the code\nthat adds the original metabolite names into functions. Start with the\ncode for the metabolite names, using the scaffold below as a starting\npoint.\n\n1.  Name the new function `add_original_metabolite_names`.\n2.  Within the `function()`, add two arguments, where the first is\n    called `model_results` and the second is called `data`.\n3.  Paste the code we created into the function, replacing `lipidomics`\n    with `data` and `model_estimates` with `model_results`.\n4.  Add `dplyr::` and `stringr::` before their respective functions.\n5.  Add the Roxygen comments (have the cursor inside the function, type `Ctrl-Shift-P`, then type \"roxygen\").\n6.  Run `{styler}` (`Ctrl-Shift-P`, then type \"style file\") to the file to fix up the code.\n7.  Cut and paste the function over into the `R/functions.R` file.\n8.  Commit the changes you've made so far.\n\n``` r\n___ <- function(___, ___) {\n  ___ %>%\n}\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Add the original metabolite names (not as snakecase) to the model results.\n#'\n#' @param model_results The data frame with the model results.\n#' @param data The original lipidomics dataset.\n#'\n#' @return A data frame.\n#'\nadd_original_metabolite_names <- function(model_results, data) {\n  data %>%\n    dplyr::mutate(term = metabolite) %>%\n    column_values_to_snakecase(term) %>%\n    dplyr::mutate(term = stringr::str_c(\"metabolite_\", term)) %>%\n    dplyr::distinct(term, metabolite) %>%\n    dplyr::right_join(model_results, by = \"term\")\n}\n```\n:::\n\n\nDo the same thing with the code that creates the model results, using\nthe scaffold below as a starting point. The only difference here is that\nwe would like to save the model results to a CSV file in the `data/`\nfolder so we can more easily share the results.\n\n``` r\ncalculate_estimates <- function(data, csv_path = \"data/model-estimates.R\") {\n  model_estimates <- ___ %>%\n    # All the other code to create the results\n    ___ %>% \n    add_original_metabolite_names(data) \n  readr::write_csv(model_estimates, here::here(csv_path))\n  output_switch_for_targets(model_estimates, csv_path)\n}\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Calculate the estimates for the model for each metabolite.\n#'\n#' @param data The lipidomics dataset.\n#'\n#' @return A data frame.\n#'\ncalculate_estimates <- function(data, csv_path = \"data/model-estimates.csv\") {\n  model_estimates <- data %>%\n    column_values_to_snakecase(metabolite) %>%\n    dplyr::group_split(metabolite) %>%\n    purrr::map(metabolites_to_wider) %>%\n    purrr::map_dfr(generate_model_results) %>%\n    dplyr::filter(stringr::str_detect(term, \"metabolite_\")) %>%\n    add_original_metabolite_names(data)\n  readr::write_csv(model_estimates, here::here(csv_path))\n  output_switch_for_targets(model_estimates, csv_path)\n}\n```\n:::\n\n\nLastly, add the model results output to end of the `_targets.R` file,\nusing the below scaffold as a guide.\n\n1.  Use `df_model_estimates` for the `name`.\n2.  Use the `calculate_estimates()` function in `command`, with\n    `lipidomics` and `\"data/model-estimates.csv\"` as the arguments.\n3.  Run `{styler}` (`Ctrl-Shift-P`, then type \"style file\") and than run `targets::tar_visnetwork()` (`Ctrl-Shift-P`, then type \"targets visual\") to see if\n    the new target gets detected. If it does, than run\n    `targets::tar_make()` (`Ctrl-Shift-P`, then type \"targets run\").\n4.  Commit the changes to the Git history.\n\n``` r\nlist(\n  ...,\n  list(\n    name = ___,\n    command = ___(___, ___),\n    format = \"file\"\n  )\n)\n```\n\n\n::: {.cell}\n\n:::\n\n\n## Visualizing the model estimates\n\nWe've got one target done for the modeling stage, three more to go!\nThere are multiple ways of visualizing the results from models. A common\napproach is to use a \"dot-and-whisker\" plot like you might see in a\nmeta-analysis. Often the \"whisker\" part is the measure of uncertainty\nlike the confidence interval, and the \"dot\" is the estimate. For the\nconfidence interval, we haven't calculated them at this point because\nthe typical approach doesn't exactly work for our data (tested before\nthe course). The next section will be covering another way of\ndetermining uncertainty. For this plot though, we will use the standard\nerror of the estimate.\n\nInside the `doc/report.Rmd`, let's create a new header and code chunk\ninside the `## Results` section. We'll want to use\n`targets::tar_read(df_model_estimates)` so that `{targets}` is aware\nthat the R Markdown file is dependent on this target. This\n`targets::tar_read()` will output a path to the CSV file, so we will\nneed to use `read_csv()` to load it in.\n\n    ### Figure of model estimates\n\n    ```{{r}}\n    model_estimates <- targets::tar_read(df_model_estimates) %>% \n      read_csv()\n    ```\n\n<!-- TODO: Add this to purl for the report.Rmd? -->\n\n\n\n\n\nThen we'll start using `{ggplot2}` to visualize the results. For\ndot-whisker plots, the \"geom\" we would use is called\n`geom_pointrange()`. It requires four values:\n\n-   `x`: This will be the \"dot\", representing the `estimate` column.\n-   `y`: This is the categorical variable that the \"dot\" is associated\n    with, in this case, it is the `metabolite` column.\n-   `xmin`: This is the lower end of the \"whisker\". Since the\n    `std.error` is a value representing uncertainty of the estimate on\n    either side of it (`+` or `-`), we will need to subtract `std.error`\n    from the `estimate`.\n-   `xmax`: This is the upper end of the \"whisker\". Like `xmin` above,\n    but adding `std.error` instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_estimates <- model_estimates %>% \n  ggplot(aes(\n    x = estimate, \n    y = metabolite,\n    xmin = estimate - std.error,\n    xmax = estimate + std.error\n  )) +\n  geom_pointrange()\nplot_estimates\n```\n\n::: {.cell-output-display}\n![](stats-analyses-multiple_files/figure-html/plot-estimates-pointrange-only-1.png){width=672}\n:::\n:::\n\n\nWoah, there is definitely something wrong here. The values of the\nestimate should realistically be somewhere between 0 (can't have a\nnegative odds) and 2 (in biology and health research, odds ratios are\nrarely above 2), definitely unlikely to be more than 5. We will\neventually need to troubleshoot this issue, but for now, let's restrict\nthe x axis to be between 0 and 5.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_estimates +\n  coord_fixed(xlim = c(0, 5))\n```\n\n::: {.cell-output-display}\n![](stats-analyses-multiple_files/figure-html/plot-estimates-coord-fixed-1.png){width=672}\n:::\n:::\n\n\nThere are so many things we could start investigating based on these\nresults in order to fix them up. But for now, this will do.\n\n## Exercise: Add plot function as a target in the pipeline\n\n> Time: \\~15 minutes.\n\nHopefully you've gotten comfortable with the function-oriented workflow,\nbecause we'll need to convert this plot code into a function and add it\nas a target in the pipeline. Use the scaffold below as a guide.\n\n1.  Replace `model_estimates` with `results`.\n2.  Use the `output_switch_for_targets()` function we created to output\n    either the `plot_results` or the `image_path`.\n3.  Move the function into the `R/functions.R` file, add\n    Roxygen comments (have the cursor inside the function, type `Ctrl-Shift-P`, then type \"roxygen\"), and run `{styler}` (`Ctrl-Shift-P`, then type \"style file\").\n\n``` r\nplot_estimates <- function(results, image_path) {\n  plot_results <- ___ %>% \n    # Plot code here:\n    ___\n  ggplot2::ggsave(\n   plot = plot_results,\n   filename = here::here(image_path)\n  )\n  output_switch_for_targets(___, ___)\n}\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Plot the estimates and standard errors of the model results.\n#'\n#' @param results The model estimate results.\n#' @param image_path Path to where image will be saved.\n#'\n#' @return A ggplot2 figure.\n#'\nplot_estimates <- function(results, image_path) {\n  plot_results <- results %>%\n    ggplot2::ggplot(ggplot2::aes(\n      x = estimate, y = metabolite,\n      xmin = estimate - std.error,\n      xmax = estimate + std.error\n    )) +\n    ggplot2::geom_pointrange() +\n    ggplot2::coord_fixed(xlim = c(0, 5))\n\n  ggplot2::ggsave(\n    plot = plot_results,\n    filename = here::here(image_path)\n  )\n  output_switch_for_targets(plot_results, image_path)\n}\n```\n:::\n\n\nThen, after doing that, add the new function as a target in the\npipeline, name the new `name` as `fig_model_estimates`.\n\n``` r\nlist(\n  ...,\n  tar_target(\n    name = ___,\n    command = plot_estimates(___, ___),\n    format = \"file\"\n  )\n)\n```\n\nAnd replace all the plot code in the `doc/report.Rmd` file with the\n`targets::tar_read()` inside the `knitr::include_graphics()`:\n\n    ```{{r}}\n    knitr::include_graphics(targets::tar_read(fig_model_estimates))\n    ```\n\nRun `targets::tar_make()` (`Ctrl-Shift-P`, then type \"targets run\") to update the pipeline. Then commit the\nchanges to the Git history.\n\n\n::: {.cell}\n\n:::\n\n\n## Determine variability in model estimates with resampling\n\nDepending on the type of research questions, there are several ways to\nassess variability (or uncertainty) in the model results. We could use\nthe calculated standard error of the estimate or calculate the\nconfidence interval from the standard error (using\n`tidy(conf.int = TRUE)`). The disadvantage of this approach is that it\nisn't very accurate for the data. Plus, when we have such small sample\nsizes, some issues can limit the use of these typical measures of\nuncertainty. And we've already noticed that there is something strange\nwith the estimates for some of the metabolites.\n\nSo instead, we can use something that is a bit more targeted to the data\ncalled \"resampling\". There are many resampling techniques, and they all\nhave slightly different uses. The one we will use is called the\n[\"bootstrap\"](https://en.wikipedia.org/wiki/Bootstrapping_(statistics))[^stats-analyses-multiple-2].\nWhat bootstrapping does is take the data and randomly resamples it as\nmany times as there are rows. This means you can potentially resample\n*the same data (in our case, person) more than once* (called \"with\nreplacement\"). So by pure chance, you could theoretically have a\n\"resampled set\" from `lipidomics` where all 36 rows are only duplicate\ndata on one person!\n\n[^stats-analyses-multiple-2]: Another common technique is called\n    [\"v-fold\n    cross-validation\"](https://en.wikipedia.org/wiki/Cross-validation_(statistics)#k-fold_cross-validation),\n    which provides a way of assessing how well the model as a whole\n    performs at fitting the data, rather than bootstrap which determines\n    how varied the estimate can be.\n\n<!-- TODO: Make a diagram of this at some point. -->\n\nWhat's the advantage of this? It is a way of directly calculating the\nstandard error from the data itself (rather than from a formula), so it\ngives a more accurate view of how uncertain the model estimate is for\nour data. Usually, creating between 50 to 100 \"resampled sets\" is\nsufficient to calculate a value for the variation. Because running\nmodels with bootstrapped sets can take a long time to process, we will\nonly resample 10 times, or less if your computer is slow.\n\nWe're using the `{rsamples}` package to handle \"resampling\". So let's\nadd it to our dependency list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_package(\"rsamples\")\n```\n:::\n\n\nWe will eventually run bootstraps on all the metabolites, so we will\nneed to use our `split_by_metabolite()` function first. For now, we will\nonly use the first item in that list (accessed with `[[1]]`) to show\nthat the code works without running on all the metabolites every time.\nCreate another code chunk at the bottom of `doc/lesson.Rmd` to add this\ncode:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlipidomics_list <- lipidomics %>%\n  split_by_metabolite()\n```\n:::\n\n\n::: callout-info\n## Reading task: \\~10 minutes\n\n> *You don't need to run the code in this reading section*.\n\nThe `bootstraps()` function is how we create resampled sets. Since this\nis done randomly, we should use `set.seed()` in order for the analysis\nto be reproducible. Nothing is truly random in computers, and instead is\nactually \"pseudorandom\". In order for our analysis to be reproducible,\nwe use `set.seed()` to force a specific \"pseudorandom\" value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1324)\nbootstraps(lipidomics_list[[1]], times = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 10 Ã— 2\n   splits          id         \n   <list>          <chr>      \n 1 <split [36/13]> Bootstrap01\n 2 <split [36/14]> Bootstrap02\n 3 <split [36/12]> Bootstrap03\n 4 <split [36/10]> Bootstrap04\n 5 <split [36/14]> Bootstrap05\n 6 <split [36/15]> Bootstrap06\n 7 <split [36/13]> Bootstrap07\n 8 <split [36/13]> Bootstrap08\n 9 <split [36/12]> Bootstrap09\n10 <split [36/14]> Bootstrap10\n```\n:::\n:::\n\n\nThis output is called a \"nested tibble\". A nested tibble is a\ntibble/data frame where one or more of the columns are actually a list\nobject. In our case, each bootstrapped set (marked by the `id`) has\ninstructions on how the resampled data will look. We can see what it\nlooks like by accessing the `splits` column and looking at the first\nitem with `[[1]]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstraps(lipidomics_list[[1]], times = 10)$splits[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n<Analysis/Assess/Total>\n<36/15/36>\n```\n:::\n:::\n\n\nThe contents of this resampled set are split into \"analysis\" sets and\n\"assessment\" sets. You don't need to worry about what these mean or how\nto use them, since a function we will later use handles it for us. But\nto give you an idea of what bootstrapping is doing here, we can access\none of the sets with either the `analysis()` or `assessment()`\nfunctions. We'll `arrange()` by `code` to show how we can have duplicate\npersons when resampling:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstraps(lipidomics_list[[1]], times = 10)$splits[[1]] %>%\n  analysis() %>%\n  arrange(code)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 36 Ã— 5\n   code   gender   age class metabolite_cd_cl_3_solvent\n   <chr>  <chr>  <dbl> <chr>                      <dbl>\n 1 ERI140 M         25 T1D                         84.6\n 2 ERI140 M         25 T1D                         84.6\n 3 ERI142 M         38 T1D                         70.8\n 4 ERI143 M         43 T1D                        204. \n 5 ERI144 M         35 T1D                        108. \n 6 ERI144 M         35 T1D                        108. \n 7 ERI144 M         35 T1D                        108. \n 8 ERI145 M         36 T1D                        133. \n 9 ERI145 M         36 T1D                        133. \n10 ERI145 M         36 T1D                        133. \n# â€¦ with 26 more rows\n```\n:::\n:::\n\n\nSee how some `code` IDs are the same? Those are the same person that has\nbeen selected randomly into this resampled set.\n:::\n\nLike we did with the previous modeling, we need to create a workflow\nobject. We'll use the first metabolite (`lipidomics_list[[1]]`) for now,\nbut will revise the code to eventually run the bootstrapping on all\nmetabolites.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow_for_bootstrap <- create_model_workflow(\n  logistic_reg() %>%\n    set_engine(\"glm\"),\n  lipidomics_list[[1]] %>%\n    create_recipe_spec(starts_with(\"metabolite_\"))\n)\n```\n:::\n\n\nPreviously, we used `fit()` on the workflow and on the data. Instead, we\nwill use `fit_resamples()` to run the model on the bootstrapped data.\nInstead of the `data` argument in `fit()`, it is the `resamples`\nargument where we provide the `bootstraps()` sets. We could run the code\nwith only the workflow object and the resampled data, but there's an\nextra argument in `fit_resamples()` that controls some actions taken\nduring the fitting by using the `control_resamples()` function. For\ninstance, we can save the predictions with `save_pred = TRUE` and we can\nprocess the output with our `tidy_model_output()` function in the\n`extract` argument. So let's do that. First, both `fit_resamples()` and\n`control_resamples()` come from the `{tune}` package, so let's add it to\nthe dependencies first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_package(\"tune\")\n```\n:::\n\n\nNow, we can write the code for `fit_resamples()` on the `bootstraps()`\nof the first item in the `lipidomics_list` and setting the `control`\noptions with `control_resamples()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrapped_results <- fit_resamples(\n  workflow_for_bootstrap,\n  resamples = bootstraps(lipidomics_list[[1]], times = 10),\n  control = control_resamples(\n    extract = tidy_model_output,\n    save_pred = TRUE\n  )\n)\nbootstrapped_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 10 Ã— 6\n   splits          id          .metrics .notes   .extracts .predicâ€¦Â¹\n   <list>          <chr>       <list>   <list>   <list>    <list>   \n 1 <split [36/13]> Bootstrap01 <tibble> <tibble> <tibble>  <tibble> \n 2 <split [36/12]> Bootstrap02 <tibble> <tibble> <tibble>  <tibble> \n 3 <split [36/13]> Bootstrap03 <tibble> <tibble> <tibble>  <tibble> \n 4 <split [36/15]> Bootstrap04 <tibble> <tibble> <tibble>  <tibble> \n 5 <split [36/17]> Bootstrap05 <tibble> <tibble> <tibble>  <tibble> \n 6 <split [36/13]> Bootstrap06 <tibble> <tibble> <tibble>  <tibble> \n 7 <split [36/12]> Bootstrap07 <tibble> <tibble> <tibble>  <tibble> \n 8 <split [36/13]> Bootstrap08 <tibble> <tibble> <tibble>  <tibble> \n 9 <split [36/17]> Bootstrap09 <tibble> <tibble> <tibble>  <tibble> \n10 <split [36/13]> Bootstrap10 <tibble> <tibble> <tibble>  <tibble> \n# â€¦ with abbreviated variable name Â¹â€‹.predictions\n```\n:::\n:::\n\n\nYou'll see that it gives another nested tibble, but with more columns\nincluded. Before we start selecting the results that we want, let's\nconvert the code above into a function, using the function-oriented\nworkflow we've used throughout the course.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Generate the model variation results using bootstrap on a single metabolite.\n#'\n#' @param data The lipidomics data.\n#'\n#' @return A nested tibble.\n#'\ngenerate_model_variation <- function(data) {\n  create_model_workflow(\n    parsnip::logistic_reg() %>%\n      parsnip::set_engine(\"glm\"),\n    data %>%\n      create_recipe_spec(tidyselect::starts_with(\"metabolite_\"))\n  ) %>%\n    tune::fit_resamples(\n      resamples = rsample::bootstraps(data, times = 10),\n      control = tune::control_resamples(\n        extract = tidy_model_output,\n        save_pred = TRUE\n      )\n    )\n}\n```\n:::\n\n\nRe-writing the code to use the function, it becomes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrapped_results <- lipidomics_list[[1]] %>%\n  generate_model_variation()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n! Bootstrap08: preprocessor 1/1, model 1/1: glm.fit: fitted probabilities numerically 0 or 1 occurred\n```\n:::\n\n```{.r .cell-code}\nbootstrapped_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 10 Ã— 6\n   splits          id          .metrics .notes   .extracts .predicâ€¦Â¹\n   <list>          <chr>       <list>   <list>   <list>    <list>   \n 1 <split [36/15]> Bootstrap01 <tibble> <tibble> <tibble>  <tibble> \n 2 <split [36/13]> Bootstrap02 <tibble> <tibble> <tibble>  <tibble> \n 3 <split [36/15]> Bootstrap03 <tibble> <tibble> <tibble>  <tibble> \n 4 <split [36/13]> Bootstrap04 <tibble> <tibble> <tibble>  <tibble> \n 5 <split [36/15]> Bootstrap05 <tibble> <tibble> <tibble>  <tibble> \n 6 <split [36/15]> Bootstrap06 <tibble> <tibble> <tibble>  <tibble> \n 7 <split [36/10]> Bootstrap07 <tibble> <tibble> <tibble>  <tibble> \n 8 <split [36/13]> Bootstrap08 <tibble> <tibble> <tibble>  <tibble> \n 9 <split [36/14]> Bootstrap09 <tibble> <tibble> <tibble>  <tibble> \n10 <split [36/13]> Bootstrap10 <tibble> <tibble> <tibble>  <tibble> \n# â€¦ with abbreviated variable name Â¹â€‹.predictions\n```\n:::\n:::\n\n\nLet's explain this output a bit. The `fit_resamples()` function outputs\na nested tibble, where each row is a resampled set. The columns that\nbegin with `.` (`.metrics` or `.extracts`) are extracted details from\neach model fit to the resampled set. We'll ignore all but the\n`.extracts` column, since that is the column that we set to extract the\n`tidy_model_output()`. Let's `select()` only the `id` and the\n`.extracts` column and use `unnest()` to convert the nested tibble to a\nregular tibble based on the column given.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrapped_results %>%\n  select(id, .extracts) %>%\n  unnest(cols = .extracts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 10 Ã— 3\n   id          .extracts        .config             \n   <chr>       <list>           <chr>               \n 1 Bootstrap01 <tibble [4 Ã— 5]> Preprocessor1_Model1\n 2 Bootstrap02 <tibble [4 Ã— 5]> Preprocessor1_Model1\n 3 Bootstrap03 <tibble [4 Ã— 5]> Preprocessor1_Model1\n 4 Bootstrap04 <tibble [4 Ã— 5]> Preprocessor1_Model1\n 5 Bootstrap05 <tibble [4 Ã— 5]> Preprocessor1_Model1\n 6 Bootstrap06 <tibble [4 Ã— 5]> Preprocessor1_Model1\n 7 Bootstrap07 <tibble [4 Ã— 5]> Preprocessor1_Model1\n 8 Bootstrap08 <tibble [4 Ã— 5]> Preprocessor1_Model1\n 9 Bootstrap09 <tibble [4 Ã— 5]> Preprocessor1_Model1\n10 Bootstrap10 <tibble [4 Ã— 5]> Preprocessor1_Model1\n```\n:::\n:::\n\n\nAlright, this is actually another nested tibble (we can see based on the\nnew column `.extracts` where each row is called a `<tibble>`). So let's\nagain `unnest()` this new `.extracts` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrapped_results %>%\n  select(id, .extracts) %>%\n  unnest(cols = .extracts) %>%\n  unnest(cols = .extracts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 40 Ã— 7\n   id          term          estimâ€¦Â¹ std.eâ€¦Â² statiâ€¦Â³ p.value .config\n   <chr>       <chr>           <dbl>   <dbl>   <dbl>   <dbl> <chr>  \n 1 Bootstrap01 (Intercept)   12.5     1.84     1.37   0.170  Preproâ€¦\n 2 Bootstrap01 genderW       15.6     1.10     2.51   0.0122 Preproâ€¦\n 3 Bootstrap01 age            0.886   0.0613  -1.97   0.0484 Preproâ€¦\n 4 Bootstrap01 metabolite_câ€¦  0.115   0.855   -2.53   0.0113 Preproâ€¦\n 5 Bootstrap02 (Intercept)    9.75    1.80     1.27   0.205  Preproâ€¦\n 6 Bootstrap02 genderW        3.75    1.16     1.14   0.254  Preproâ€¦\n 7 Bootstrap02 age            0.902   0.0656  -1.58   0.115  Preproâ€¦\n 8 Bootstrap02 metabolite_câ€¦  0.0243  1.51    -2.46   0.0138 Preproâ€¦\n 9 Bootstrap03 (Intercept)    0.0552  1.76    -1.65   0.0995 Preproâ€¦\n10 Bootstrap03 genderW        0.809   0.833   -0.254  0.800  Preproâ€¦\n# â€¦ with 30 more rows, and abbreviated variable names Â¹â€‹estimate,\n#   Â²â€‹std.error, Â³â€‹statistic\n```\n:::\n:::\n\n\nNow this is something we are familiar with looking at! It shows the\n`term`, the `estimate`, as well as the bootstrap `id`. Like before, we\nonly want the metabolite `estimate`, so we can use `filter()` and\n`str_detect()` like last time, as well as add the original variable\nnames with `add_original_metabolite_names()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrapped_results %>%\n  select(id, .extracts) %>%\n  unnest(cols = .extracts) %>%\n  unnest(cols = .extracts) %>%\n  filter(str_detect(term, \"metabolite_\")) %>%\n  add_original_metabolite_names(lipidomics)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 10 Ã— 8\n   metabolite    term  id    estimâ€¦Â¹ std.eâ€¦Â² statiâ€¦Â³ p.value .config\n   <chr>         <chr> <chr>   <dbl>   <dbl>   <dbl>   <dbl> <chr>  \n 1 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 1.15e-1   0.855   -2.53 0.0113  Preproâ€¦\n 2 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 2.43e-2   1.51    -2.46 0.0138  Preproâ€¦\n 3 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 2.70e-1   0.776   -1.68 0.0922  Preproâ€¦\n 4 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 5.97e-3   2.42    -2.12 0.0344  Preproâ€¦\n 5 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 1.60e-1   0.779   -2.36 0.0185  Preproâ€¦\n 6 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 7.05e-2   0.988   -2.69 0.00723 Preproâ€¦\n 7 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 1.13e-1   0.847   -2.57 0.0101  Preproâ€¦\n 8 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 7.98e-8  11.6     -1.41 0.159   Preproâ€¦\n 9 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 5.89e-2   1.12    -2.53 0.0115  Preproâ€¦\n10 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 2.00e-1   0.536   -3.00 0.00268 Preproâ€¦\n# â€¦ with abbreviated variable names Â¹â€‹estimate, Â²â€‹std.error,\n#   Â³â€‹statistic\n```\n:::\n:::\n\n\nUsing the same workflow as before, let's convert this into a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Tidy up the bootstrap output.\n#'\n#' @param bootstrap_results The bootstrap object with model results.\n#'\n#' @return A data frame.\n#'\ntidy_bootstrap_output <- function(bootstrap_results) {\n  bootstrap_results %>%\n    dplyr::select(id, .extracts) %>%\n    # Need to unnest twice since first `.extracts` is a nest of another two\n    # columns of `.extracts` and `.config`.\n    tidyr::unnest(cols = .extracts) %>%\n    tidyr::unnest(cols = .extracts) %>%\n    dplyr::filter(stringr::str_detect(term, \"metabolite_\")) %>%\n    add_original_metabolite_names(lipidomics)\n}\n```\n:::\n\n\nThen we can start from the beginning again, right from `lipidomics`, to\n`split_by_metabolite()`, to `map()`'ing with\n`generate_model_variation()`, and finally to `map_dfr()` with\n`tidy_bootstrap_output()`. Keep in mind, this will take a while to run.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetabolites_with_bootstrap_results <- lipidomics %>%\n  split_by_metabolite() %>%\n  map(generate_model_variation) %>%\n  map_dfr(tidy_bootstrap_output)\nmetabolites_with_bootstrap_results\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n# A tibble: 120 Ã— 8\n   metabolite    term  id    estimâ€¦Â¹ std.eâ€¦Â² statiâ€¦Â³ p.value .config\n   <chr>         <chr> <chr>   <dbl>   <dbl>   <dbl>   <dbl> <chr>  \n 1 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.112     0.870   -2.52 0.0118  Preproâ€¦\n 2 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.0208    1.35    -2.88 0.00401 Preproâ€¦\n 3 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.0713    0.896   -2.95 0.00321 Preproâ€¦\n 4 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.00833   2.36    -2.03 0.0421  Preproâ€¦\n 5 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.0475    1.11    -2.74 0.00623 Preproâ€¦\n 6 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.0269    1.44    -2.52 0.0118  Preproâ€¦\n 7 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.0974    0.804   -2.90 0.00377 Preproâ€¦\n 8 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.0153    1.77    -2.36 0.0183  Preproâ€¦\n 9 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.0192    1.51    -2.62 0.00873 Preproâ€¦\n10 CDCl3 (solveâ€¦ metaâ€¦ Bootâ€¦ 0.267     0.609   -2.17 0.0300  Preproâ€¦\n# â€¦ with 110 more rows, and abbreviated variable names Â¹â€‹estimate,\n#   Â²â€‹std.error, Â³â€‹statistic\n```\n:::\n:::\n\n\n## Exercise: Convert to function and add as a target in the pipeline\n\n> Time: \\~15 minutes.\n\nContinue the workflow we've applied throughout the course:\n\n1.  Move the code into a function structure (use the scaffold below as a\n    guide).\n2.  Include two arguments in the `function()` called `data` and\n    `results_path`.\n3.  Replace `lipidomics` in the code with `data`.\n4.  Add the Roxygen comments (have the cursor inside the function, type `Ctrl-Shift-P`, then type \"roxygen\").\n5.  Cut and paste the function over into the `R/functions.R` file.\n6.  Run `{styler}` (`Ctrl-Shift-P`, then type \"style file\") and `lintr::lint_dir()` in the R Console (try to fix any\n    issues).\n7.  Commit the changes to the Git history.\n\nUse this code as a guide for the function.\n\n``` r\ncalculate_variation <- function(___, results_path = \"data/model-variation.csv\") {\n  bootstrapped_results <- ___ %>% \n    # Code from above.\n    ___\n  readr::write_csv(bootstrapped_results, here::here(results_path))\n  output_switch_for_targets(bootstrapped_results, results_path)\n}\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\n#' Calculate the uncertainty in results.\n#'\n#' @param data The lipidomics data.\n#' @param results_path Path to save a CSV of the results.\n#'\n#' @return A data frame (or file path)\n#'\ncalculate_variation <- function(data, results_path = \"data/model-variation.csv\") {\n  bootstrapped_results <- data %>%\n    split_by_metabolite() %>%\n    map(generate_model_variation) %>%\n    map_dfr(tidy_bootstrap_output)\n  readr::write_csv(bootstrapped_results, here::here(results_path))\n  output_switch_for_targets(bootstrapped_results, results_path)\n}\n```\n:::\n\n\nNext, add the function to `_targets.R`.\n\n1.  Create another `tar_target()` item in the `list()` at the bottom of\n    the file.\n2.  Use `df_model_variation` as the `name` and `calculate_variation()`\n    as the `command` with `lipidomics` and `\"data/model-variation.csv\"`\n    as the two arguments.\n3.  Set `\"file\"` as the `format`.\n4.  Run `targets::tar_visnetwork()` (`Ctrl-Shift-P`, then type \"targets visual\") to see what targets are outdated and then\n    run `targets::tar_make()` (`Ctrl-Shift-P`, then type \"targets run\").\n5.  Commit the changes to the Git history.\n\nUse this code as a scaffold:\n\n``` r\nlist(\n  ...,\n  tar_target(\n    name = ___,\n    command = ___,\n    format = ___\n  )\n)\n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are struggling or are out of time.\"}\nlist(\n  # ...,\n  tar_target(\n    name = df_model_variation,\n    command = calculate_variation(lipidomics, \"data/model-variation.csv\"),\n    format = \"file\"\n  )\n)\n```\n:::\n\n\n## Visualizing the variability of results\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nTake your time explaining why we might use a figure like this, and what\nyou're trying to show. Since there isn't much code involved, there is\ntime to explain.\n:::\n\nLike we did with the estimates, let's visualize the results. Visualizing\nthe estimates was pretty easy, visualizing the variation is even easier.\nWe want to show the range of `estimate` values across all the\nbootstrapped models, by `metabolite` variable. There's a neat geom in\n`{ggplot2}` called `geom_dotplot()` that is similar to a histogram, but\ninstead shows individual data points instead of bars. And since we want\nto show the variation by `metabolite`, we can use `facet_wrap()`. We\nwill use `scales = \"free\"` because the range of values for `estimate`\nare different for each `metabolite`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetabolites_with_bootstrap_results %>%\n  ggplot(aes(x = estimate)) +\n  geom_dotplot() +\n  facet_wrap(vars(metabolite), scales = \"free\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nBin width defaults to 1/30 of the range of the data. Pick better\nvalue with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](stats-analyses-multiple_files/figure-html/plot-variation-1.png){width=672}\n:::\n:::\n\n\nThis nicely shows the ranges of values in the `estimate`, really\nhighlighting how uncertain the results are for answering our original\nresearch questions. This figure could also be improved quite a bit from\na visual and aesthetic point of view, but at least from a content point\nof view, it shows what we want. For now, we'll stick with this and\nfinish our last pipeline target before putting everything into the\n`doc/report.Rmd` file.\n\nLet's use our function workflow with this code:\n\n1.  Create the code as a function, add a `data` argument, and replace\n    the input data object name with `data`.\n2.  Move the code into the `R/functions.R` file.\n3.  Add the Roxygen comments (have the cursor inside the function, type `Ctrl-Shift-P`, then type \"roxygen\") and fill it in.\n4.  Run `{styler}` (`Ctrl-Shift-P`, then type \"style file\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Plot the uncertainty in the estimates of the models.\n#'\n#' @param model_results The model results with the variation.\n#'\n#' @return A ggplot2 image (or a file path).\n#'\nplot_variation <- function(model_results, image_path) {\n  plot_output <- model_results %>%\n    ggplot2::ggplot(ggplot2::aes(x = estimate)) +\n    ggplot2::geom_dotplot() +\n    ggplot2::facet_wrap(ggplot2::vars(metabolite), scales = \"free\")\n  ggplot2::ggsave(here::here(image_path), plot_output)\n  output_switch_for_targets(plot_output, image_path)\n}\n```\n:::\n\n\nThen we'll add it as a pipeline target to the `_targets.R` file.\n\n``` r\nlist(\n  ...,\n  tar_target(\n    name = fig_model_variation,\n    command = plot_variation(df_model_variation, \"images/fig-model-variation.png\"),\n    format = \"file\"\n  )\n)\n```\n\nRun `targets::tar_visnetwork()` (`Ctrl-Shift-P`, then type \"targets visual\") and then run `targets::tar_make()` (`Ctrl-Shift-P`, then type \"targets run\"). Once\neverything has been built, commit everything to the Git history.\n\n## Combine all the output into the R Markdown file\n\nNow its' time to add the model results and plots to the `doc/report.Rmd`\nfile. Open it up and create another code chunk at the bottom of the\nfile. Like we did with the other outputs (like the figures), we'll use\n`tar_read()` to reference the image path.\n\n    ```{{r}}\n    knitr::include_graphics(tar_read(fig_model_estimates))\n    ```\n\n    ```{{r}}\n    knitr::include_graphics(tar_read(fig_model_variations))\n    ```\n\nRun `targets::tar_visnetwork()` (`Ctrl-Shift-P`, then type \"targets visual\"), then `targets::tar_make()` (`Ctrl-Shift-P`, then type \"targets run\"). We now have the\nreport rendered to an HTML file! If you open it up in a browser, we can\nsee the figures added to it. In the next session we will get more into\nmaking the document output nicer looking and creating it as a website.\n\nTODO: Check that the output is rendered to html. Don't forget the TODO\n:)\n\n## Summary\n\n-   Use functional programming with `map()`, as part of the\n    function-oriented workflow, to run multiple models efficiently and\n    with minimal code.\n-   Consistently create small functions that do a specific conceptual\n    action and chain them together into larger conceptual actions, which\n    can then more easily be incorporated into a `{targets}` pipeline.\n    Small, multiple functions combined together are easier to manage\n    than fewer, bigger ones.\n-   Use dot-whisker plots like `geom_pointrange()` to visualize the\n    estimates and their standard error.\n-   Use resampling techniques like `bootstraps()`, combined with\n    `fit_resamples()`, to calculate measures of variation specific to\n    the data. Combine with functionals like `map()` to run large numbers\n    of models, easily and with minimal code.\n-   Visualize variation in data with alternatives to histograms like\n    `geom_dotplot()`.\n",
    "supporting": [
      "stats-analyses-multiple_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}