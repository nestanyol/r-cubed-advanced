{
  "hash": "2eeb93b5282ca3af17014c9247611df9",
  "result": {
    "markdown": "# Smoother project-based collaboration {#sec-smoother-collaboration}\n\n\n\n::: callout-warning\n🚧 This section is being actively worked on. 🚧\n:::\n\n\n\nMany of you probably work largely and most consistently on your own, but\nas your move through your career (in academia or industry), you will\nneed to and maybe also want to *directly\ncollaborate*[^smoother-collaboration-1] a lot more with others.\nDifferent types of collaboration (e.g. meetings, brainstorming,\nreal-time co-writing) form the basis for almost all research-based work\nand probably most non-research-based work.\n\n[^smoother-collaboration-1]: Collaborate here meaning directly\n    contributing to a shared project, rather than discussed or planning\n    based collaborations (and definitely not emailing-files-around\n    collaboration).\n\nMore direct collaboration on a project quickly becomes unmanageable when\nusing traditional academic \"workflows\" (emailing around). That's when\nyou need to start using tools designed for collaboration, like Git. But\nGit is just the starting point. There are many many other things to\nconsider for workflows and processes to effectively collaborate with\nothers. This session is about making use of more automated ways of\nstructuring data analysis projects to ease collaboration.\n\n## Learning objectives\n\nThe overall objective for this session is to:\n\n1.  Identify potential actions to streamline collaboration on a data\n    analysis project and create projects that apply many of these\n    actions using R.\n\nMore specific objectives are to:\n\n1.  Explain what a \"project-oriented\" workflow is, what a project-level\n    R dependency management is, what a \"project environment\" is, and why\n    these concepts are important to consider in collaborative and\n    reproducible analyses.\n2.  Describe the difference between \"workflow dependencies\" and \"build\n    dependencies\".\n3.  Apply functions in the `{renv}` and `{usethis}` R packages to\n    implement these dependency management concepts.\n4.  Explain the role that following a style guide has on building a\n    common approach to reading (and writing) R code, and thus improve\n    project-level collaboration.\n5.  Use `{styler}`, `{lintr}`, and RStudio's canonical markdown mode to\n    programmatically check and apply style guides to your project files.\n\n## Exercise: How do you *exactly* collaborate or contribute? To your own or others' projects.\n\n> Time: \\~10 minutes.\n\nWhen you work on a project (for your thesis or a manuscript), how\n**exactly** do you and your collaborators contribute to the project? Is\nit mostly verbal contributions? Do you use a shared folder that the\nfiles are on? How do you keep track of who's changed what? Do you mostly\nwork on your own and contributions are largely verbal or written\nfeedback (like in a meeting or through an email)? If you work directly\non a project, how do you coordinate things? Does one collaborator work\non one section or analysis, so your files are separate? Do you ever have\nto go in and contribute your own code to theirs (and vice versa)?\n\n1.  Take 2 minutes to think on these questions.\n2.  For 6 minutes, discuss these questions with your neighbour, and talk\n    about your own experiences.\n3.  For the remaining time, we will share briefly with everyone.\n\n## Project-level R dependency management\n\n> Note: This first session is more conceptual and is heavier on the\n> reading and explanation, but is important for the next sessions.\n\nOne of the first things to consider when working collaboratively on a\ndata analysis project (and probably other types of projects too) is what\nsoftware to use for your project. This starts out at the highest level:\nAre you using R or some other software for the analysis? Since this is\nan R course, we're assuming the software will be R! 😜\n\nThe next consideration is which packages your project depends on to\nproduce the results. When working collaboratively with others, and\nyourself several months in the future, you need some way of knowing how\nto easily and quickly install or update these package dependencies.\n\nPart of this approach requires that you follow a [\"project-oriented\"\nworkflow](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/)\nwhen working on, well, your project. In order to know how to track your\nproject's package dependencies, you need to first know, what is a\n\"project\" and how do we work around it? Since the introduction course's\nfirst session on the [Management of R\nProjects](https://r-cubed.rostools.org/r-project-management.html), we've\nconsistently taught and used this workflow-style. In fact, it is\nembedded into the use of the R Projects via the `.Rproj` files and in\nthe use of the `{here}` package. So we already are following this\napproach from the start, which will make it easier to track package\ndependencies of our project.\n\n![Cartoon of combining R Projects with the `{here}` package, compared to\nthe common approach of using `setwd()`. [Artwork by\n\\@allison_horst.](https://allisonhorst.com/allison-horst)](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/e684ee45-98fc-469e-997c-e2d68b0096cd_rw_1920.png?h=d754f634e6fc1e292430124fbe44dad7)\n\nLet's start with the `AdvancedR3` project that uses the `lipidomics`. We\nhave code in the `data-raw/nmr-omics.R` file that uses some packages.\nLet's assume that your project will be more complex than this and that\nyou will eventually need some collaborators to contribute who are\nexperts in for instance metabolomics data processing and in statistical\nanalysis of high-dimensional data. You know you will end up needing to\nuse other packages. You also know that you all need some way of tracking\nwhich packages are used so that when others join and contribute to the\nproject, they can as seamlessly as possible install or update the\npackages your data analysis project needs. There are a few ways of\n\"tracking\" package dependencies.\n\n::: callout-info\n## Reading task: \\~5 minutes\n\n1.  The simplest, but most primitive way is to always make sure to use\n    `library()` at the top of each R script for each package that the R\n    script uses.\n\n    -   Advantage:\n\n        -   This is the easiest to conceptually understand and to use.\n\n    -   Disadvantages:\n\n        -   It doesn't track project-level dependencies very well, since\n            multiple scripts probably use similar packages across them.\n            Which means you can't easily and quickly install or update\n            all the packages your project uses, since you will probably\n            have to go through each R script manually and install each\n            package manually. You might have seen some scripts with code\n            that looks like this at the top:\n\n            ``` r\n            if (!require(\"packagename\")) {\n              install.packages(\"packagename\")\n            }\n            ```\n\n            This code checks if a package exists, if not, it installs\n            it. But! This is not an optimal method to track packages\n            because `require()` won't load the package if it doesn't\n            find it. Which means you would have to re-run the script\n            probably a few times. Plus, sometimes you may need to\n            restart the R session after installing a package in order\n            for R to detect it properly.\n\n        -   It doesn't track the *versions* of the packages your project\n            depends on, so if a package gets updated and it breaks\n            something, you might not be able to figure out how to\n            quickly fix that issue, especially for those deadline\n            crunches.\n\n2.  The most common form, at least based on R packages and projects\n    found on GitHub, makes use of the `DESCRIPTION` file and\n    `usethis::use_package()` to track if a package is used for a project\n    or not. We covered this style of dependency in the [intermediate\n    course](https://r-cubed-intermediate.rostools.org/dry-functions.html#continuing-the-workflow).\n    We will also use this approach during this course, but expand a lot\n    more on it.\n\n    -   Advantages:\n\n        -   Relatively easy to conceptually understand, since you can\n            directly view the packages your project needs by opening the\n            `DESCRIPTION` file and looking at the contents.\n\n        -   Because it is widely used, there are many processes already\n            built around making use of tracking dependencies this way.\n            For instance, you need to track package dependencies when\n            creating R packages.\n\n        -   Installing packages is as easy as opening the project and\n            running `remotes::install_deps()` in the Console, which will\n            install all the packages listed in the `DESCRIPTION` file.\n\n        -   Adding packages that you need is as easy as writing\n            `usethis::use_package(\"packagename\")` in the Console.\n\n    -   Disadvantages:\n\n        -   Like the previous method, it doesn't easily keep track of\n            the versions of the packages you are using.\n\n        -   Your project might still rely on a package that is installed\n            on *your* computer and that influences your project, but\n            that might not be obvious as a dependency or that you forgot\n            to include.\n:::\n\nBefore continuing to the exercise, we need to make sure to add and\ncomment all the files from the project into the Git history. Open the\nGit interface by either typing `Ctrl-Shift-M` or by going to the Git\npane and clicking the \"Commit\" button.\n\n## Exercise: Add packages from the data processing script\n\n> Time: \\~10 minutes.\n\nSince the `DESCRIPTION` file will be used later on for the more formal\ndependency management, let's get it updated with the packages we are\nusing in the `data-raw/nmr-omics.R` script. Open that file and complete\nthese tasks:\n\n1.  Look for package dependencies that are declared with `library()` and\n    `::`. It can help to use \"Find / Replace Text\" feature in RStudio\n    for all the `::` used in the script. Use the Command Palette\n    (`Ctrl-Shift-P`, then \"find replace\") to quickly select this option,\n    or `Edit -> Find and replace` (`Ctrl-Shift-J`).\n2.  Use `?usethis::use_package` to review how to use this function.\n3.  In the Console, run `usethis::use_package()` for each package you\n    find in `data-raw/nmr-omics.R` (from 1. above).\n4.  Once done, open the Git interface (`Ctrl-Shift-M` or go to the Git\n    Pane and click the \"Commit\" button). What has been changed? Commit\n    those changes to the Git history.\n    -   You'll see a newly created file called `.Rbuildignore`. We don't\n        really need this for this course, so let's do\n        `usethis::use_git_ignore(\".Rbuildignore\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"**Click for the solution**. Only click if you are really struggling or are out of time for the exercise.\"}\nusethis::use_package(\"stringr\")\nusethis::use_package(\"readxl\")\nusethis::use_package(\"dplyr\")\nusethis::use_package(\"tidyr\")\nusethis::use_package(\"snakecase\")\nusethis::use_package(\"here\")\nusethis::use_package(\"fs\")\nusethis::use_package(\"usethis\")\n```\n:::\n\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nMake sure that everyone has added the right packages, since it can be\neasy to miss some of the packages referenced using `::`.\n:::\n\n\n::: {.cell}\n\n:::\n\n\n## Formal dependency management\n\nWhile the approach of managing package dependencies through the\n`DESCRIPTION` file is quite powerful, it has the major disadvantage of\nnot keeping track of the *version* of each of your packages. So instead\nwe are going to use a package dedicated to handling project\ndependencies, called `{renv}`.\n\n![Cartoon showing a simplified version of what `{renv}` does for R\nProjects, by making them more self-contained. [Artwork by\n\\@allison_horst.](https://allisonhorst.com/allison-horst)](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/3c1eda6b-be13-4257-9c32-4cf865f171ae_rw_1920.png?h=5a6482956a683b2fc417f965674456de)\n\n`{renv}` is a package that manages package dependencies in a project by,\nin simple terms, creating a project-specific R \"library\". You might\nthink of `library()` when you hear R library, and you aren't completely\nwrong. When you call, for instance, `library(\"usethis\")`, R looks for\nthe package `{usethis}` in your computer's \"library\" of R packages. This\nlibrary can be found by running this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.libPaths()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n[1] \"/home/luke/.cache/R/renv/library/r-cubed-advanced-611f9650/R-4.2/x86_64-pc-linux-gnu\"          \n[2] \"/home/luke/Documents/teaching/r-cubed-advanced/renv/sandbox/R-4.2/x86_64-pc-linux-gnu/9a444a72\"\n[3] \"/usr/local/lib/R/site-library\"                                                                 \n[4] \"/usr/lib/R/site-library\"                                                                       \n[5] \"/usr/lib/R/library\"                                                                            \n```\n:::\n:::\n\n\nThose file paths are where all R packages are installed to. If there is\nmore than one path, R checks the first before continuing to the next.\n`{renv}` instead creates a file path for R packages to be installed\nwithin the project. This isn't completely what it does, since there are\na lot of very technical details to what `{renv}` does internally, but\nthis is the basic concept.\n\nIn the end, this makes your project relatively self-contained in its\npackage dependencies.\n\n-   Advantages:\n\n    -   Installing all packages necessary for your project is as easy as\n        running `renv::restore()`. `{renv}` even gives you helpful tips\n        and instructions when things go wrong or if something is\n        missing.\n\n    -   *Every* package, including the packages that your packages\n        depend on, have their version tracked. So if a package gets\n        updated on CRAN, it doesn't affect you *until you choose*, using\n        `renv::update()`. If a package update breaks your code and you\n        have a deadline, you can easily go back to the older versions of\n        the packages.\n\n    -   Because your project is now self-contained with its own R\n        library, it becomes very obvious (through errors) when you might\n        be missing some other dependency because your code wouldn't run\n        until you install or fix that package dependency.\n\n    -   From a reproducibility point of view, as long as your project is\n        tracked by `{renv}`, it's easier to independently have your data\n        analysis be reproduced and verified.\n\n-   Disadvantages:\n\n    -   It takes a fair amount of learning to conceptually understand\n        what is going on.\n\n    -   When there are issues that come up, it can be difficult to\n        figure them out.\n\n    -   Because *all* packages, including those packages that your\n        packages depend on, are installed within your project,\n        installation times can sometimes be a bit long.\n\n::: aside\nIt's sometimes very annoying to debug these \"virtual environments\". But\nthankfully you can turn it off with `renv::deactivate()`! It still is\nworth it to start considering and accounting for how your dependencies\nmight influence your project results and collaboration.\n:::\n\nLet's start using `{renv}` in our `AdvancedR3` project. In the Console,\ntype out:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::init(bare = TRUE)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThe function `renv::init()` initializes the project to begin being\nmanaged by `{renv}`. By using the argument `bare = TRUE` we are telling\n`{renv}` to not search for dependencies in the project, since we want to\ndo that ourselves.\n\nWhen initilizing a `{renv}` instance using `bare = TRUE` we create a new\n`.libPath()` location that does not contain any of the packages we\npreviously defined as project dependencies. You can notice this if you\nattempt to type `usethis::`, you'll notice that nothing comes up.\nTherefore, before being able to continue our workflow we need to tell\n`{renv}` to install the packages we have already defined as\ndependencies. This can be done with `renv::install()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::install()\n```\n:::\n\n\nAfter doing this we should have several files in our project folder:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\n.\n├── .Rprofile\n├── renv\n│   ├── .gitignore\n│   ├── activate.R\n│   ├── sandbox\n│   ├── settings.dcf\n│   └── staging\n└── renv.lock\n```\n:::\n:::\n\n\n-   `.Rprofile`: This is the file that `{renv}` uses to build up its\n    machinery. With an `.Rprofile` within the project folder, we can\n    create a \"project environment\". By having this project environment\n    that is (mostly) self-contained, it allows us to be a bit closer to\n    having a fully reproducible analysis and it makes it easier to\n    collaborate, since we all than share the same project setup.\n\n-   `renv.lock`: This contains all the information about the packages\n    your project depends on, including where it was installed from (CRAN\n    or GitHub for example), what the version number is, and more. This\n    is like a supercharged version of the `DESCRIPTION` file.\n\n-   `renv/`: This folder contains several other files that make up the\n    machinery of `{renv}`. For instance, there is the `library/` folder\n    that contains all the R packages necessary for the project. Then\n    there are the `activate.R` script and `settings.dcf` file that both\n    work to manage the dependencies, like installing, updating, and\n    removing.\n\n\n```{mermaid}\n%%| label: fig-renv-environment\n%%| fig-cap: Simple schematic of how renv is a separate environment.\n%%| echo: false\n%%| eval: true\n%%{init:{'theme':'forest', 'flowchart':{'nodeSpacing': 40, 'rankSpacing': 20}}}%%\ngraph LR\n    user[\"far:fa-folder User/\"] --- root_docs\n    user --- root_desktop\n    user --- .Rprofile\n    subgraph global[Global fab:fa-r-project environment]\n        root_docs[\"far:fa-folder Documents/\"] --- r[\"far:fa-folder R/ (global fab:fa-r-project library)\"]\n        root_desktop[\"far:fa-folder Desktop/\"] --- renv[\"far:fa-folder AdvancedR3/\"]\n        root_docs --- 3[\"far:fa-folder other-projects/\"]\n        .Rprofile\n        subgraph renv_env[Project fab:fa-r-project environment]\n            renv --- renv_folder[\"far:fa-folder renv/<br/>(fab:fa-r-project library)\"]\n            renv --- proj_prof[.Rprofile]\n        end\n    end\n\nlinkStyle 0,1,2,3,4,5,6,7 stroke-width:1px;\n\nclassDef folderEnv fill:transparent,stroke-dasharray:5;\nclass renv_env,global folderEnv\n```\n\n\n**Before we continue, let's commit the new files to the Git history**.\n\nThe general workflow for using `{renv}` while working on your project is\ndescribed in more detail on the [Introduction to\nrenv](https://rstudio.github.io/renv/articles/renv.html#workflow)\nwebpage. However, unlike the general workflow, we also want to continue\nusing the `DESCRIPTION` file. That's because a lot of tools and\nworkflows exist that make use of it, so we want to remain compatible\nwith them.\n\nAs we work on the project and realize we need to use a specific package,\nwe would normally use `install.packages()` and then add `library()` to\nthe script or R Markdown file. Later on, we'd eventually run\n`renv::snapshot()` to update the `renv.lock` file with the new packages\nwe've installed. `renv::snapshot()` as well as `renv::init()` usually\nrely on \"implicit\" dependencies, meaning `{renv}` will search throughout\nthe project for any packages used and add them to the `renv.lock` file.\n\nHowever, in science, we want to be more explicit rather than implicit.\nThe way `{renv}` explicitly adds to the `renv.lock` file is by only\nscanning the `DESCRIPTION` file. In order for `{renv}` to always do\nthis, we need to set an option for it. This option needs to be added to\nthe project's `.Rprofile` file.\n\nWe can quickly open this with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::edit_r_profile(\"project\")\n```\n:::\n\n\nNext, at the top of the file, add this code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(\n  renv.settings.snapshot.type = \"explicit\",\n  renv.config.auto.snapshot = TRUE\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThese two options make it so that whenever you add a package with\n`usethis::use_package()` or `install.packages()`, `{renv}` will always\nrun `renv::snapshot()` and the snapshot explicitly only look at the\n`DESCRIPTION` file. Let's restart the R session so that the `.Rprofile`\nchanges get activated.\n\nNow our `{renv}` workflow will largely be automated for us, as long as\nwe do `usethis::use_package()`. If we ever ever return to a project or\ncollaborate on a project that uses `{renv}`, we can install all the\nnecessary packages with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::restore()\n```\n:::\n\n\nAnd if we need to update packages, we use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::update()\n```\n:::\n\n\n*Sometimes*, working with `{renv}` can get annoying and you just need to\nfinish working on a task. If that's the case, you can always do\n`renv::deactivate()` to stop using `{renv}` and `renv::activate()` to\nreactivate it.\n\n**Let's commit the changes made to the Git history**.\n\n::: callout-info\n## Reading task: \\~5 minutes\n\nIt's surprising how many issues can come up, from a reproducibility\nperspective, when it comes to managing package dependencies. You think\nsomething works well on your computer, but when you create a \"virtual\nenvironment\" like you do when using `{renv}`, you realize it might not\nwork as well on other computers.\n\nWhen this happens, there are several functions you can use to help debug\nthe situation.\n\n`renv::diagnostics()`\n\n:   List a *lot* of diagnostic information to look over. Sometimes its\n    too much, but can help figure out what's going on.\n\n`renv::clean()`\n\n:   Installing packages can sometimes lead to issues in the files of the\n    installed packages themselves or even left over temporary files.\n    This function tries to clean up these issues for you. It can also\n    clean up any unused packages\n\n`renv::repair()`\n\n:   Because of the way `{renv}` works, the connection to where an\n    installed package is actually found can get broken. So this function\n    tries to fix that and reinstall these broken packages.\n\n`renv::rebuild()`\n\n:   The last resort, use this to reinstall everything from scratch.\n:::\n\n## Exercise: Browse the newly created `renv/` folders and files\n\n> Time: \\~10 minutes.\n\nAfter running adding `{renv}` to the project, take a look through the\nnewly created `renv/` folder and see what was added. Where are the\npackages now installed?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\nrenv\n├── .gitignore\n├── activate.R\n├── sandbox\n│   └── R-4.2\n├── settings.dcf\n└── staging\n```\n:::\n:::\n\n\nTo better understand how `{renv}` creates this self-contained project,\nrun this line of code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.libPaths()\n```\n:::\n\n\nNotice where the file paths are. Then, run this code in the Console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::deactivate()\n```\n:::\n\n\nOpen up the Git interface and see what was modified in the `.Rprofile`\nfile. What was changed? Now switch back to the Console and run these\nlines of code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.libPaths()\nrenv::activate()\n```\n:::\n\n\nNotice how the file path location of the R library is different when\n`{renv}` is active or not?\n\n## Two types of dependencies\n\nWhen you work on a research project that involves data analysis, you\nlikely use packages in two different ways:\n\n1.  Packages that directly contribute to data wrangling, analysis,\n    plotting, and making the manuscript. These types of packages are\n    generally called \"build\" or \"deploy\" dependencies. A package like\n    `{dplyr}` or `{tidyr}` would be build dependencies, since you use\n    them for processing data.\n2.  Packages that assist you in doing your work but aren't directly used\n    for data analysis. These types of packages would be called\n    \"workflow\" or \"development\" dependencies. `{renv}` would be\n    considered a workflow dependency.\n\nA good way to determine if a package is a *build dependency* for your\nproject is by seeing if you write and use functions from the package\nwithin an R script that does something to the data or analysis. If you\n*only* ever use functions from the package in the Console, than it is\nlikely a *workflow dependency*.\n\nThe way you add these packages is different depending on the type it is.\nFor build dependencies, we use the function we've already used before:\n`usethis::use_package(\"packagename\")`. For workflow dependencies, it's\nthe same function, but with a small difference. BUT! Before we cover it,\nlet's add a setting to our `.Rprofile` to make our life a bit easier. We\nwill be using `{usethis}` functions many times throughout the course, so\na simple quality-of-life fix is to make it so we don't always have to do\n`usethis::`. Thankfully, there is a function that can help. Create and\nopen the project `.Rprofile` with `usethis::edit_r_profile()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::edit_r_profile(\"project\")\n```\n:::\n\n\nThen copy and paste this code into the `.Rprofile`:\n\n``` r\nif (interactive()) {\n  suppressMessages(require(usethis))\n}\n```\n\n\n::: {.cell}\n\n:::\n\n\nLet's restart R (`Ctrl-Shift-P` then type \"restart r\") before using\n`use_package()` to add `{renv}` as a workflow dependency.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_package(\"renv\", \"suggests\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nOpen the Git interface and see that under `Suggests:` in the\n`DESCRIPTION` file is `renv`. Let's commit these changes, as well as the\nchanges to `.Rprofile`.\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nFor the information block below, mention it to the learners but you\ndon't need to go over it.\n:::\n\n::: callout-tip\nWhen you come back to a project after a few months or if you start\ncollaborating on a project, usually `renv::restore()` will be enough to\ninstall all types of dependencies. Sometimes though, workflow\ndependencies might not get installed. As long as they are tracked in the\n`DESCRIPTION` file though, you can force installation of them with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrenv::install()\n```\n:::\n\n:::\n\n## \"Linting\" your code\n\nWhen you're working on your own and not needing to worry about anyone\nseeing your code, there's a natural temptation to write your code like\nyou might write notes to yourself... scribbled and scrawled down\nquickly. Even when you are working with others or try to write more\nreadable code, it still is very easy for\n\"lint\"[^smoother-collaboration-2] to accumulate.\n\n[^smoother-collaboration-2]: You know, the fluff you find in your\n    pockets 😝\n\nThat's when \"linters\" (a type of \"static code analysis\" tool) become\nvery useful. A linter will scan your code for common mistakes or syntax\nproblems and list them out for you to fix. They don't directly fix them\nfor you, though we will show how to do that later in this session.\nLinters are great when you are collaborating on a project with\ncollaborators who are not as experienced in writing code or who only\noccasionally contribute so don't know the workflow culture of your\nproject. In this way, you might want to have automatic linting checks\n(or styling) that are independent of you having to run them yourself.\n\nThe main package for doing that is the `{lintr}` package. We'll get a\nchance to try out using `{renv}` since we need to install it to use it\nin our project.\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nBefore continuing, ask the learners which type of dependency they think\n`{lintr}` is or should be.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_package(\"lintr\", \"suggests\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nRight now we don't have much code to \"lint\", but as we work through the\ncourse, we will make use of `{lintr}` before committing to Git. So, how\ndo we use `{lintr}`? It's actually pretty easy, since there are only a\nfew functions that do the linting, even though there are dozens of\ncustomizations you can make to `{lintr}`. The basic is to lint a single\nfile, don't run this though:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlintr::lint(\"R/functions.R\")\n```\n:::\n\n\nA more encompassing function checks all files in the project (also,\ndon't run it yet, we'll do that when we have more code in the project):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlintr::lint_dir()\n```\n:::\n\n\nThis might be useful if you want to go over everything to check things.\nBut, if you are working on a single file and want to do some linting of\nthat, the better solution is to use the Command Palette (`Ctrl-Shift-P`)\nand type \"lint\". The first option is to lint the file you are working\non. Let's open up the `data-raw/nmr-omics.R` script and try it out.\nThere should be at least one note that says\n\n``` markdown\nLines should not be more than 80 characters.\n```\n\nKeep in mind, that not all notes need to be changed. A linter is meant\nto be used as a guideline, not as a rule. It helps you to follow best\npractices and have some consistency between collaborators, but not to\nstress about making sure all notes are addressed.\n\nSince we will eventually connect our project Git repository to GitHub to\ndisplay a website, we can actually make use of a really powerful service\ncalled [GitHub\nActions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions)\nto also run `{lintr}` there for us. But before we can do that, we need\nto connect to GitHub. So before doing the next exercise, let's all\n**commit the changes to the Git history**.\n\n## Exercise: Connect your project to GitHub\n\n> Time: \\~25 minutes.\n\nLet's complete these tasks to connect to GitHub.\n\n1.  If you haven't yet, please create a\n    [GitHub](https://github.com/join) account.\n2.  Read through and complete the tasks in @sec-connect-github.\n3.  Check your GitHub to make sure the project repository has been\n    uploaded to it.\n\n## Adding lintr to your GitHub\n\nNow that your `AdvancedR3` project is connected and up on GitHub, we can\nmake use of the GitHub Actions. The RStudio team has a\n[repository](https://github.com/r-lib/actions/tree/v2/examples#example-workflows)\nthat lists all R \"Actions\" that you can use to help streamline checks on\nyour project. Specifically, we want to add the one for `{lintr}`, which\nwe can add with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_github_action(\"lint-project\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThis creates a file in `.github/workflows/lint-project.yaml`. In order\nfor GitHub to start using it, we need to **commit it to the Git history\nand than push it to GitHub**.\n\nOnce you've done that, switch to your project on GitHub and click the\n\"Actions\" tab at the top. Then click the \"lint-project\" link on the\nsidebar. This lists the checks that `{lintr}` has done on your project\nin an independent environment.\n\n## Automatically adhere to a style guide\n\nAn advantage of `{lintr}` is that it does not make the changes it\ndetects for you, but the disadvantage of `{lintr}` is that it does not\nmake the changes for you. Often checks that require manual action are\nthe best way of finding and fixing things. But sometimes, especially\nwith very common syntax formatting mistakes, like not using spacing\nproperly, it is so much easier to have the computer fix it for you.\nThankfully there is the `{styler}` package!\n\nSince we will use it for the project as a workflow dependency, let's add\nit to the `DESCRIPTION` file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_package(\"styler\", \"suggests\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLike `{lintr}`, there are only a few functions in `{styler}` that we\nneed to use. The first is to style a single file, so let's try it in the\nConsole:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstyler::style_file(\"data-raw/nmr-omics.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.sourceCode}\nStyling  1  files:\n data-raw/nmr-omics.R ✔ \n────────────────────────────────────────\nStatus\tCount\tLegend \n✔ \t1\tFile unchanged.\nℹ \t0\tFile changed.\n✖ \t0\tStyling threw an error.\n────────────────────────────────────────\n```\n:::\n:::\n\n\nSince we already have the file all nice and tidy, it doesn't do\nanything. But, this function is a bit much to type. We could also do it\non all files in the project with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstyler::style_dir()\n```\n:::\n\n\n::: callout-note\nYou will probably be asked to install something, click \"Yes\".\n:::\n\nBut, like the linting we did above, we only need to style all the files\noccasionally. Usually we would need to only style the file we are\nactually working. We can do that through the Command Palette\n(`Ctrl-Shift-P`) and typing \"style file\", which should show the \"Style\nactive file\" option. You'll try it out in the next exercise.\n\nThe thing to note, though, is that `{styler}` isn't perfect, so by using\nit together with `{lintr}` and sometimes manually running reformatting\n(`Ctrl-Shift-A` or with the Command Palette `Ctrl-Shift-P` then\n\"reformat\") you will be able to fix most syntax issues.\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nMention the callout block below, but don't go into it at all.\n:::\n\n::: callout-tip\nYou might be used to using 4 spaces for tabs instead of 2. The tidyverse\nstyle uses 2, so the default option in `{styler}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(\n  styler.addins_style_transformer = \"styler::tidyverse_style(indent_by = 4)\"\n)\n```\n:::\n\n:::\n\n## Exercise: Copy and paste code that is very wrong.\n\n> Time: \\~15 minutes.\n\n1.  Open your `doc/lesson.Rmd` file, create a new code chunk\n    (`Ctrl-Shift-I` or `Ctrl-Shift-P` followed by typing \"chunk\") at the\n    end of the file. Copy and paste the below code:\n\n    ``` r\n    library(dplyr)\n    load ( here::here( \"data/lipidomics.rda\") \n    )\n    lipidomics%>%select(gender , age)%>%filter(age>=25)\n    ```\n\n2.  Open the Git interface and commit the changes to the Git history.\n    Then push the changes to GitHub. Go to the Actions tab and see what\n    happens. It might take a few minutes to finish.\n\n3.  Go back to `doc/lesson.Rmd` file in RStudio and run `lintr::lint()`\n    with the Command Palette (`Ctrl-Shift-P` then type \"lint file\").\n    What happens? Don't do anything just yet, simply see what things\n    were identified as potential issues.\n\n4.  Run `styler::style_file()` using the Command Palette (`Ctrl-Shift-P`\n    then type \"style file\") while inside the `doc/lesson.Rmd` file. What\n    happens? Open the Git interface to see the changes made. Commit the\n    changes and push to GitHub. Go into the Actions tab to see what is\n    different now.\n\n5.  Re-run the `lintr::lint()` with the Command Palette. What's changed\n    since you did it last?\n\n## Styling Markdown files\n\nFor multi-person collaborative projects, having some type of code\nstyling and checker can really help with standardizing how the code\nlooks, which ultimately will make it easier to read each other's code\ncontributions.\n\nBut what about for Markdown files? While there isn't a package or\nfunction (yet) that styles the Markdown files, RStudio does have an\noption in their Tools to format Markdown into a \"canonical form\". The\nreason for this option is because they added a \"visual editor mode\" to\nwriting R Markdown files (which is great if you are more comfortable\nwith apps like Word). Let's test out this option. First, let's make sure\neverything has been committed to the Git history.\n\n::: callout-warning\nUse this option *only if* you have your project under Git version\ncontrol, since it will directly modify and overwrite the contents of the\nentire file.\n:::\n\nThere are two ways of doing this:\n\n1.  Going into\n    [`Tools -> Project Options -> R Markdown`](https://rstudio.github.io/visual-markdown-editing/options.html#project-options)\n    and changing the options \"Automatic text wrapping\" to \"column\" (with\n    the default 72 width value) and \"Write canonical visual mode\n    markdown\" to \"true\".\n2.  Or setting [YAML\n    options](/https://rstudio.github.io/visual-markdown-editing/markdown.html#writer-options)\n    in either the project-level `_quarto.yml` file (we will cover this\n    in @sec-build-website) or at the file-level in the YAML header.\n\nFor right now, we will do the file-level YAML settings. Open the\n`doc/lesson.Rmd` file and go to the top of the file. Right below the\nlast `---`, create a new line above it and paste this code in:\n\n``` yaml\neditor_options:\n  markdown:\n    wrap: 72\n    canonical: true\n```\n\n\n::: {.cell}\n\n:::\n\n\nNow, when you save your file, RStudio should automatically reformat the\nMarkdown into a standardized format. If you want to switch to using the\nVisual Mode, use `Ctrl-Shift-F4` or the \"Visual\" button at the top of\nthe Source Pane beside the bolding and italicizing buttons.\n\nThe instructors won't be using the Visual Mode during the course,\nhowever you are welcome to. We will be using the \"canonical\" markdown\nmode though.\n\nLet's test it out. While in the `doc/lesson.Rmd` file, go to the bottom\nof the file and type out:\n\n``` markdown\n## This is poorly formatted\n- Definitely should have an empty space above this list.\n- This isn't a list, why not?\n```\n\nSave the file. What happens? Lists in Markdown must have an empty space\nabove them to work properly. With this canonical mode on, we can get\nfeedback right away that it isn't right. We fix it by adding that empty\nspace.\n\n``` markdown\n## This is poorly formatted\n\n- Definitely should have an empty space above this list.\n- This isn't a list, why not?\n```\n\nSince this mode is on automatically, as we work through the sessions,\nwe'll get lots of experience using it.\n\n## Exercise: A few small changes to improve your workflow\n\n> Time: \\~2 minutes.\n\nThere are many options inside the Global Options in RStudio that can\nhelp you work better and faster. There are a few that will help a lot,\nespecially in this course and with the workflows we are showing:\n\n-   Go into `Tools -> Global Options -> Code -> Saving`.\n    -   Under the heading \"General\", tick on all of those check boxes.\n    -   Under the heading \"Auto-save\", tick on both those check boxes.\n\n## Exercise: Update the README file, while using canonical markdown mode\n\n> Time: \\~10 minutes.\n\nOpen up the `README.md` file and copy and paste these YAML metadata to\nthe top:\n\n``` markdown\n---\neditor_options:\n  markdown:\n    wrap: 72\n    canonical: true\n---\n```\n\nThen, start completing the `TODO` items. Save often and watch as the\nMarkdown gets reformatted. After you are done, commit the changes you\nmade to the Git history. Then delete both `TODO.md`, followed by\ncommitting these deletions in the Git history. Click the \"Push\" button\nto push the changes to GitHub.\n\n::: {.callout-note appearance=\"minimal\" collapse=\"true\"}\n## Instructor note\n\nUse this code to help synchronize with what the learners are doing. Copy\nand paste this code into the RStudio Console of the `AdvancedR3`\nproject.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neditor_yaml <- \"\n---\neditor_options:\n  markdown:\n    wrap: 72\n    canonical: true\n---\n\"\nreadLines(\"README.md\") |>\n  append(editor_yaml, after = 1) |>\n  writeLines(\"README.md\")\ngit_ci(\"README.md\", \"Add editor options to README file.\")\ngert::git_rm(\"TODO.md\")\ngert::git_commit(\"Don't need this file anymore.\")\n```\n:::\n\n:::\n\n## Summary\n\n-   Track your project package dependencies with `{renv}` and combine it\n    with `options()` to automatically make snapshots so you can use the\n    `use_package()` function.\n-   Install the necessary dependencies with `renv::restore()` or\n    `renv::install()`.\n-   Follow a style guide by using `{lintr}` and `{styler}`. Combine with\n    the Command Palette (`Ctrl-Shift-P`) to quickly run their functions\n    on code you are actively working on.\n-   Use RStudio's canonical markdown mode to reformat Markdown into a\n    standard format.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}